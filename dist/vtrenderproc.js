/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/VoxelTracer/RenderProc/vtrenderprocess.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Animation/AudioVisAnimatorDefaultConfigs.js":
/*!*********************************************************!*\
  !*** ./src/Animation/AudioVisAnimatorDefaultConfigs.js ***!
  \*********************************************************/
/*! exports provided: SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE, SOUND_VIZ_HISTORY_BARS_LEVEL_SCENE_TYPE, SOUND_VIZ_FIRE_SCENE_TYPE, SOUND_VIZ_TYPES, soundVisDefaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE\", function() { return SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_VIZ_HISTORY_BARS_LEVEL_SCENE_TYPE\", function() { return SOUND_VIZ_HISTORY_BARS_LEVEL_SCENE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_VIZ_FIRE_SCENE_TYPE\", function() { return SOUND_VIZ_FIRE_SCENE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_VIZ_TYPES\", function() { return SOUND_VIZ_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"soundVisDefaultConfig\", function() { return soundVisDefaultConfig; });\n/* harmony import */ var _VoxelTracer_Scenes_Audio_AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs */ \"./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js\");\n/* harmony import */ var _WebClientViewer_SoundController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebClientViewer/SoundController */ \"./src/WebClientViewer/SoundController.js\");\n\r\n\r\n\r\nconst SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE    = \"Basic Bars\";\r\nconst SOUND_VIZ_HISTORY_BARS_LEVEL_SCENE_TYPE  = \"History Bars\";\r\nconst SOUND_VIZ_FIRE_SCENE_TYPE                = \"Fire\";\r\n\r\nconst SOUND_VIZ_TYPES = [\r\n  SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE,\r\n  SOUND_VIZ_HISTORY_BARS_LEVEL_SCENE_TYPE,\r\n  SOUND_VIZ_FIRE_SCENE_TYPE,\r\n];\r\n\r\nconst soundVisDefaultConfig = {\r\n  levelMax: _VoxelTracer_Scenes_Audio_AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_LEVEL_MAX\"],\r\n  fftBufferSize: _WebClientViewer_SoundController__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_FFT_BUFFER_SIZE\"],\r\n  numFFTSamples: _WebClientViewer_SoundController__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_NUM_FFT_SAMPLES\"],\r\n  gamma: _VoxelTracer_Scenes_Audio_AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_GAMMA\"],\r\n  fadeFactor: _VoxelTracer_Scenes_Audio_AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_FADE_FACTOR\"],\r\n\r\n  sceneType: SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE,\r\n  sceneConfig: {..._VoxelTracer_Scenes_Audio_AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__[\"basicBarsAudioVisDefaultConfig\"]},\r\n};\n\n//# sourceURL=webpack:///./src/Animation/AudioVisAnimatorDefaultConfigs.js?");

/***/ }),

/***/ "./src/Animation/AudioVisualizerAnimator.js":
/*!**************************************************!*\
  !*** ./src/Animation/AudioVisualizerAnimator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _AudioVisAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioVisAnimatorDefaultConfigs */ \"./src/Animation/AudioVisAnimatorDefaultConfigs.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _VoxelTracer_Scenes_Audio_FireAudioVisScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VoxelTracer/Scenes/Audio/FireAudioVisScene */ \"./src/VoxelTracer/Scenes/Audio/FireAudioVisScene.js\");\n/* harmony import */ var _VoxelTracer_Scenes_Audio_BasicBarsAudioVisScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../VoxelTracer/Scenes/Audio/BasicBarsAudioVisScene */ \"./src/VoxelTracer/Scenes/Audio/BasicBarsAudioVisScene.js\");\n/* harmony import */ var _VoxelTracer_Scenes_Audio_HistoryBarsAudioVisScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VoxelTracer/Scenes/Audio/HistoryBarsAudioVisScene */ \"./src/VoxelTracer/Scenes/Audio/HistoryBarsAudioVisScene.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AudioVisualizerAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(voxelModel, vtScene, config={..._AudioVisAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"soundVisDefaultConfig\"]}) {\r\n    super(voxelModel, config);\r\n\r\n    // Cross-fading variables\r\n    this._totalCrossfadeTime = _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_CROSSFADE_TIME_SECS\"];\r\n    this._crossfadeCounter = Infinity;\r\n    this._prevSceneConfig = null;\r\n\r\n    this.currAudioInfo = null;\r\n    this._scene = vtScene;\r\n    this._sceneMap = {\r\n      [_AudioVisAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"SOUND_VIZ_BASIC_BARS_LEVEL_SCENE_TYPE\"]]:  new _VoxelTracer_Scenes_Audio_BasicBarsAudioVisScene__WEBPACK_IMPORTED_MODULE_6__[\"default\"](vtScene, this.voxelModel),\r\n      [_AudioVisAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"SOUND_VIZ_HISTORY_BARS_LEVEL_SCENE_TYPE\"]]: new _VoxelTracer_Scenes_Audio_HistoryBarsAudioVisScene__WEBPACK_IMPORTED_MODULE_7__[\"default\"](vtScene, this.voxelModel),\r\n      [_AudioVisAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"SOUND_VIZ_FIRE_SCENE_TYPE\"]]: new _VoxelTracer_Scenes_Audio_FireAudioVisScene__WEBPACK_IMPORTED_MODULE_5__[\"default\"](vtScene, this.voxelModel),\r\n    };\r\n\r\n    this.setConfig(config);\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"].VOXEL_ANIM_SOUND_VIZ; }\r\n\r\n  setConfig(c) {\r\n    // Check whether the scene type has changed\r\n    if (this.config.sceneType !== c.sceneType) {\r\n      if (this.config.sceneType) {\r\n        // Crossfade between the previous scene and the new scene\r\n        this._prevSceneConfig = this.config;\r\n        this._crossfadeCounter = 0;\r\n      }\r\n    }\r\n\r\n    super.setConfig(c);\r\n    \r\n    if (this._sceneMap) {\r\n      const {sceneType} = c;\r\n      this.audioVisualizer = this._sceneMap[sceneType];\r\n      if (this.audioVisualizer) {\r\n        this.audioVisualizer.rebuild(c);\r\n      }\r\n      else {\r\n        this.audioVisualizer = null;\r\n        console.error(\"Invalid audio scene type: \" + sceneType);\r\n      }\r\n    }\r\n  }\r\n\r\n  setAudioInfo(audioInfo) {\r\n    this.currAudioInfo = audioInfo;\r\n  }\r\n\r\n  rendersToCPUOnly() { return this._prevSceneConfig === null; }\r\n\r\n  async render(dt) {\r\n    if (this.currAudioInfo) {\r\n      this.audioVisualizer.updateAudioInfo(this.currAudioInfo);\r\n\r\n      // When crossfading we need to update both scenes\r\n      if (this._prevSceneConfig) {\r\n        const prevScene = this._sceneMap[this._prevSceneConfig.sceneType];\r\n        prevScene.updateAudioInfo(this.currAudioInfo);\r\n      }\r\n\r\n      this.currAudioInfo = null;\r\n    }\r\n\r\n    // Crossfade between scenes\r\n    if (this._prevSceneConfig) {\r\n      const prevScene = this._sceneMap[this._prevSceneConfig.sceneType];\r\n\r\n      // Adjust the scene alphas as a percentage of the crossfade time and continue counting the total time until the crossfade is complete\r\n      const percentFade = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(this._crossfadeCounter / this._totalCrossfadeTime, 0, 1);\r\n      const prevSceneFBIdx = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CPU_FRAMEBUFFER_IDX_0;\r\n      const currSceneFBIdx = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CPU_FRAMEBUFFER_IDX_1;\r\n\r\n      this._scene.clear();\r\n      prevScene.build(this._prevSceneConfig);\r\n\r\n      this.voxelModel.setFramebuffer(prevSceneFBIdx);\r\n      this.voxelModel.clear();\r\n      await prevScene.render(dt);\r\n\r\n      if (this._crossfadeCounter < this._totalCrossfadeTime) {\r\n        this._crossfadeCounter += dt;\r\n      }\r\n      else {\r\n        // No longer crossfading, just showing the current visualizer\r\n        this._crossfadeCounter = Infinity;\r\n        this._prevSceneConfig = null;\r\n      }\r\n\r\n      this._scene.clear();\r\n      this.audioVisualizer.build(this.config);\r\n\r\n      this.voxelModel.setFramebuffer(currSceneFBIdx);\r\n      this.voxelModel.clear();\r\n      await this.audioVisualizer.render(dt);\r\n\r\n      // Now we set the default render framebuffer for the animator and we combine the two scene framebuffers into it\r\n      this.voxelModel.setFramebuffer(_Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GPU_FRAMEBUFFER_IDX_0);\r\n      this.voxelModel.drawCombinedFramebuffers(\r\n        currSceneFBIdx, prevSceneFBIdx, \r\n        {mode: _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].FB1_ALPHA_FB2_ONE_MINUS_ALPHA, alpha: percentFade}\r\n      );\r\n    }\r\n    else {\r\n      await this.audioVisualizer.render(dt);\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    //this.audioVisualizer.clear();\r\n    //this.currAudioInfo = null;\r\n  }\r\n\r\n  setCrossfadeTime(t) {\r\n    this._totalCrossfadeTime = t;\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioVisualizerAnimator);\n\n//# sourceURL=webpack:///./src/Animation/AudioVisualizerAnimator.js?");

/***/ }),

/***/ "./src/Animation/FireAnimator.js":
/*!***************************************!*\
  !*** ./src/Animation/FireAnimator.js ***!
  \***************************************/
/*! exports provided: fireAnimatorDefaultConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fireAnimatorDefaultConfig\", function() { return fireAnimatorDefaultConfig; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _Randomizers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Randomizers */ \"./src/Animation/Randomizers.js\");\n/* harmony import */ var _Fluid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Fluid */ \"./src/Fluid.js\");\n/* harmony import */ var _Spectrum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Spectrum */ \"./src/Spectrum.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst fireAnimatorDefaultConfig = {\r\n  speed: 2.0,\r\n  buoyancy:  1.2,\r\n  cooling:   1,\r\n  initialIntensityMultiplier: 8,\r\n  vorticityConfinement: 8.0,\r\n  spectrumTempMin: 500,\r\n  spectrumTempMax: 1700,\r\n  colourSystem: 'CIEsystem',\r\n};\r\n\r\nclass FireAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(voxelModel, config=fireAnimatorDefaultConfig) {\r\n    super(voxelModel, config);\r\n    this.reset();\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"].VOXEL_ANIM_FIRE; }\r\n\r\n  setConfig(c) {\r\n    let regenFireLookup = false;\r\n    {\r\n      const {spectrumTempMin, spectrumTempMax, colourSystem} = this.config;\r\n      regenFireLookup = (c.spectrumTempMin !== spectrumTempMin || c.spectrumTempMax !== spectrumTempMax || c.colourSystem !== colourSystem);\r\n    }\r\n\r\n    super.setConfig(c);\r\n\r\n    const {buoyancy, cooling, vorticityConfinement} = c;\r\n\r\n    if (!this.fluidModel) {\r\n      this.fluidModel = new _Fluid__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.voxelModel.gridSize);\r\n    }\r\n    this.fluidModel.diffusion = 0.0001;\r\n    this.fluidModel.viscosity = 0;\r\n    this.fluidModel.buoyancy  = buoyancy;\r\n    this.fluidModel.cooling   = cooling;\r\n    this.fluidModel.vc_eps    = vorticityConfinement;\r\n\r\n    if (regenFireLookup) {\r\n      this.genFireColourLookup();\r\n    }\r\n  }\r\n\r\n  render(dt) {\r\n    const {speed, initialIntensityMultiplier} = this.config;\r\n\r\n    const xSize = this.voxelModel.xSize();\r\n    const zSize = this.voxelModel.zSize();\r\n\r\n    // Offsets are used because the fluid model has two extra values on either side of each buffer in all dimensions in order\r\n    // to properly calculate the derivatives within the grid. We need to get the values inside that margin and place them\r\n    // into our voxel grid.\r\n    const startX = 1;\r\n    const endX = xSize+startX;\r\n    const startZ = 1;\r\n    const endZ = zSize+startZ;\r\n    const startY = 1;\r\n\r\n    for (let x = startX; x < endX; x++) {\r\n      for (let z = startZ; z < endZ; z++) {\r\n        let f = this.genFunc(x-startX, z-startZ, endX-startX, endZ-startZ, this.t, this.randomArray);\r\n        const idx = this.fluidModel._I(x, startY, z);\r\n        this.fluidModel.sd[idx] = 1.0;\r\n        this.fluidModel.sT[idx] = 1.0 + f*initialIntensityMultiplier;\r\n      }\r\n    }\r\n    const speedDt = dt*speed;\r\n    this.fluidModel.step(speedDt);\r\n    this.t += speedDt;\r\n\r\n    // Update the voxels...\r\n    const gpuFramebuffer = this.voxelModel.framebuffer;\r\n    gpuFramebuffer.drawFire(this.fireLookup, this.fluidModel.T, [startX, startY, startZ]);\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    this.randomArray = _Randomizers__WEBPACK_IMPORTED_MODULE_2__[\"Randomizer\"].getRandomFloats(_Spectrum__WEBPACK_IMPORTED_MODULE_4__[\"FIRE_SPECTRUM_WIDTH\"]);\r\n    this.t = 0;\r\n  }\r\n\r\n  genFireColourLookup() {\r\n    const {spectrumTempMin, spectrumTempMax, colourSystem} = this.config;\r\n    const spectrum = Object(_Spectrum__WEBPACK_IMPORTED_MODULE_4__[\"generateSpectrum\"])(spectrumTempMin, spectrumTempMax, _Spectrum__WEBPACK_IMPORTED_MODULE_4__[\"FIRE_SPECTRUM_WIDTH\"], _Spectrum__WEBPACK_IMPORTED_MODULE_4__[\"ColourSystems\"][colourSystem]);\r\n\r\n    const {gpuKernelMgr} = this.voxelModel; \r\n    this.fireLookup = gpuKernelMgr.fireLookupGen(spectrum);\r\n\r\n  }\r\n\r\n  genFunc(x, y, sx, sy, t, p) {\r\n    let pi = 0;\r\n    let f = 0;\r\n    let i = 0;\r\n\r\n    for (; i < 12; i++) {\r\n      f += (1.0 +\r\n        Math.sin(x/sx*_MathUtils__WEBPACK_IMPORTED_MODULE_5__[\"PI2\"]*(p[pi++]+1)+p[pi++]*_MathUtils__WEBPACK_IMPORTED_MODULE_5__[\"PI2\"] + p[pi++]*t) *\r\n        Math.sin(y/sy*_MathUtils__WEBPACK_IMPORTED_MODULE_5__[\"PI2\"]*(p[pi++]+1)+p[pi++]*_MathUtils__WEBPACK_IMPORTED_MODULE_5__[\"PI2\"] + p[pi++]*t)) *\r\n        (1 + Math.sin((p[pi++]+0.5)*t + p[pi++]*_MathUtils__WEBPACK_IMPORTED_MODULE_5__[\"PI2\"])) * 0.25;\r\n    }\r\n    f *= 1.0/i;\r\n\r\n    let fx = (x < sx*0.9) ? 1.0 : 1.0-(x-sx*0.9)/(sx*0.2);\r\n    if (x < sx*0.1) {\r\n      fx = 0.5 + x/(sx*0.2);\r\n    }\r\n    let fy = (y < sy*0.9) ? 1.0 : 1.0-(y-sy*0.9)/(sy*0.2);\r\n    if (y < sy*0.1) {\r\n      fy = 0.5 + y/(sy*0.2);\r\n    }\r\n\r\n    return f * fx * fy;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FireAnimator);\n\n//# sourceURL=webpack:///./src/Animation/FireAnimator.js?");

/***/ }),

/***/ "./src/Animation/Randomizers.js":
/*!**************************************!*\
  !*** ./src/Animation/Randomizers.js ***!
  \**************************************/
/*! exports provided: Randomizer, UniformFloatRandomizer, UniformIntRandomizer, UniformSetRandomizer, UniformVector3Randomizer, Vector3DirectionRandomizer, ColourRandomizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Randomizer\", function() { return Randomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformFloatRandomizer\", function() { return UniformFloatRandomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformIntRandomizer\", function() { return UniformIntRandomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformSetRandomizer\", function() { return UniformSetRandomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformVector3Randomizer\", function() { return UniformVector3Randomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3DirectionRandomizer\", function() { return Vector3DirectionRandomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColourRandomizer\", function() { return ColourRandomizer; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ \"chroma-js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n\r\n\r\n\r\n\r\nclass Randomizer {\r\n  constructor() {\r\n  }\r\n\r\n  generate() {\r\n  }\r\n  static getRandomFloat(min, max) {\r\n    return three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].randFloat(min, max);\r\n  }\r\n  static getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive\r\n  }\r\n  static getRandomIntInclusive(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min; // The maximum is inclusive and the minimum is inclusive \r\n  }\r\n\r\n  static getRandomFloats(size, min=0, max=1) {\r\n    let result = new Array(size);\r\n    for (let i = 0; i < size; i++) {\r\n      result[i] = Randomizer.getRandomFloat(min,max);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates random floating point numbers in the range [min,max).\r\n */\r\nclass UniformFloatRandomizer extends Randomizer {\r\n  constructor(min = 0.0, max = 1.0) {\r\n    super();\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  get average() {\r\n    return (this.min + this.max) / 2.0;\r\n  }\r\n\r\n  generate() {\r\n    return Randomizer.getRandomFloat(this.min, this.max);\r\n  }\r\n}\r\n\r\n/**\r\n * Generates random integer numbers in the range [min,max) or [min,max] given\r\n * the value of the \"isMaxExclusive\" option.\r\n */\r\nclass UniformIntRandomizer extends Randomizer {\r\n  constructor(min = 0, max = 1, isMaxExclusive = true) {\r\n    super();\r\n    this.min = min;\r\n    this.max = max;\r\n    this.isMaxExclusive = isMaxExclusive;\r\n  }\r\n\r\n  get average() {\r\n    return (this.min + this.max) / 2.0;\r\n  }\r\n\r\n  generate() {\r\n    return this.isMaxExclusive ? \r\n      Randomizer.getRandomInt(this.min, this.max) :\r\n      Randomizer.getRandomIntInclusive(this.min, this.max);\r\n  }\r\n}\r\n\r\n/**\r\n * Chooses a uniform random element from the given array/set.\r\n */\r\nclass UniformSetRandomizer extends Randomizer {\r\n  constructor(possibleVals = []) {\r\n    this.possibleVals = possibleVals;\r\n  }\r\n  generate() {\r\n    return this.possibleVals[Randomizer.getRandomInt(0,this.possibleVals.length)];\r\n  }\r\n}\r\n\r\nclass UniformVector3Randomizer extends Randomizer {\r\n  constructor(min = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), max = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1,1,1)) {\r\n    super();\r\n    this.min = min.clone();\r\n    this.max = max.clone();\r\n  }\r\n  generate() {\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](\r\n      three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].randFloat(this.min.x, this.max.x),\r\n      three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].randFloat(this.min.y, this.max.y),\r\n      three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].randFloat(this.min.z, this.max.z)\r\n    );\r\n  }\r\n}\r\n\r\nclass Vector3DirectionRandomizer extends Randomizer {\r\n  constructor(baseDirection, radAngle = 0) {\r\n    super();\r\n    this.baseDirection = baseDirection.clone().normalize();\r\n    this.radAngle = radAngle;\r\n  }\r\n\r\n  generate() {\r\n    // Generate points on the spherical cap around the north pole.\r\n    // See https://math.stackexchange.com/a/205589/81266\r\n    const z = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].randFloat(0,1) * (1 - Math.cos(this.radAngle)) + Math.cos(this.radAngle);\r\n    const phi = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].randFloat(0,1) *  2 * Math.PI;\r\n    const x = Math.sqrt(1-z*z)*Math.cos(phi);\r\n    const y = Math.sqrt(1-z*z)*Math.sin(phi);\r\n    \r\n    const zVec = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,1);\r\n    const result = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x, y, z);\r\n\r\n    // If the spherical cap is centered around the north pole, we're done\r\n    if (this.baseDirection.distanceToSquared(zVec) < _MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"VOXEL_EPSILON\"]) {\r\n      return result;\r\n    }\r\n\r\n    // Otherwise we need to get a perpendicular rotation axis 'u' and rotation angle 'rot'\r\n    const u = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n    u.crossVectors(zVec, this.baseDirection);\r\n    const rot = Math.acos(this.baseDirection.dot(zVec));\r\n    \r\n    // Convert rotation axis and angle to a rotation matrix\r\n    const R = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\r\n    R.makeRotationAxis(u, rot);\r\n    \r\n    return result.applyMatrix4(R);\r\n  }\r\n}\r\n\r\nclass ColourRandomizer extends Randomizer {\r\n  constructor(min = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0), max = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1)) {\r\n    super();\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  generate() {\r\n    const temp = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.min), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.max), Randomizer.getRandomIntInclusive(0,1000)/1000).gl();\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](temp[0], temp[1], temp[2]);\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      min: {r: this.min.r, g: this.min.g, b: this.min.b}, \r\n      max: {r: this.max.r, g: this.max.g, b: this.max.b}\r\n    };\r\n  }\r\n\r\n  toString() {\r\n    return \"min: (\" + this.min.r + \", \" + this.min.g + \", \" + this.min.b + \"), max: (\" + this.max.r + \", \" + this.max.g + \", \" + this.max.b + \")\";\r\n  }\r\n\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/Animation/Randomizers.js?");

/***/ }),

/***/ "./src/Animation/SceneAnimator.js":
/*!****************************************!*\
  !*** ./src/Animation/SceneAnimator.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _SceneAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SceneAnimatorDefaultConfigs */ \"./src/Animation/SceneAnimatorDefaultConfigs.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _VoxelTracer_Scenes_SimpleScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VoxelTracer/Scenes/SimpleScene */ \"./src/VoxelTracer/Scenes/SimpleScene.js\");\n/* harmony import */ var _VoxelTracer_Scenes_ShadowScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../VoxelTracer/Scenes/ShadowScene */ \"./src/VoxelTracer/Scenes/ShadowScene.js\");\n/* harmony import */ var _VoxelTracer_Scenes_FogScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VoxelTracer/Scenes/FogScene */ \"./src/VoxelTracer/Scenes/FogScene.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SceneAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(voxelModel, vtScene, config={..._SceneAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"sceneAnimatorDefaultConfig\"]}) {\r\n    super(voxelModel, config);\r\n    \r\n    // Cross-fading variables\r\n    this._totalCrossfadeTime = _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_CROSSFADE_TIME_SECS\"];\r\n    this._crossfadeCounter = Infinity;\r\n    this._prevSceneConfig = null;\r\n    \r\n    this._scene = vtScene;\r\n    this._sceneMap = {\r\n      [_SceneAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"SCENE_TYPE_SIMPLE\"]]:  new _VoxelTracer_Scenes_SimpleScene__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this._scene, this.voxelModel),\r\n      [_SceneAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"SCENE_TYPE_SHADOW\"]]:  new _VoxelTracer_Scenes_ShadowScene__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this._scene, this.voxelModel),\r\n      [_SceneAnimatorDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"SCENE_TYPE_FOG\"]]   :  new _VoxelTracer_Scenes_FogScene__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this._scene, this.voxelModel),\r\n    };\r\n\r\n    this.setConfig(config);\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"].VOXEL_ANIM_SCENE; }\r\n\r\n  setConfig(c) {\r\n    // Check whether the scene type has changed\r\n    if (this.config.sceneType !== c.sceneType) {\r\n      if (this.config.sceneType) {\r\n        // Crossfade between the previous scene and the new scene\r\n        this._prevSceneConfig = this.config;\r\n        this._crossfadeCounter = 0;\r\n      }\r\n    }\r\n\r\n    super.setConfig(c);\r\n\r\n    const {sceneType, sceneOptions} = c;\r\n    if (this._sceneMap) {\r\n      const currScene = this._sceneMap[sceneType];\r\n      if (currScene) {\r\n        currScene.rebuild(sceneOptions);\r\n      }\r\n      else {\r\n        console.error(\"Invalid scene type: \" + sceneType);\r\n      }\r\n    }\r\n  }\r\n\r\n  rendersToCPUOnly() { return true; }\r\n\r\n  async render(dt) {\r\n    const currScene = this._sceneMap[this.config.sceneType];\r\n\r\n    // Crossfade between scenes\r\n    if (this._prevSceneConfig) {\r\n      const prevScene = this._sceneMap[this._prevSceneConfig.sceneType];\r\n\r\n      // Adjust the scene alphas as a percentage of the crossfade time and continue counting the total time until the crossfade is complete\r\n      const percentFade = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(this._crossfadeCounter / this._totalCrossfadeTime, 0, 1);\r\n      const prevSceneFBIdx = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CPU_FRAMEBUFFER_IDX_0;\r\n      const currSceneFBIdx = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CPU_FRAMEBUFFER_IDX_1;\r\n\r\n      // Rebuild and render the previous scene - this must be rendered into a CPU framebuffer\r\n      prevScene.rebuild(this._prevSceneConfig.sceneOptions);\r\n      this.voxelModel.setFramebuffer(prevSceneFBIdx);\r\n      this.voxelModel.clear();\r\n      await prevScene.render(dt);\r\n\r\n      if (this._crossfadeCounter < this._totalCrossfadeTime) {\r\n        this._crossfadeCounter += dt;\r\n      }\r\n      else {\r\n        // no longer crossfading, reset to just showing the current scene\r\n        this._crossfadeCounter = Infinity;\r\n        this._prevSceneConfig = null;\r\n      }\r\n\r\n      // Rebuild and render the current scene into a different CPU buffer from the previous scene\r\n      currScene.rebuild(this.config.sceneOptions);\r\n      this.voxelModel.setFramebuffer(currSceneFBIdx);\r\n      this.voxelModel.clear();\r\n      await currScene.render(dt);\r\n\r\n      // Now we set the default render framebuffer for the animator and we combine\r\n      // the two scene framebuffers into it\r\n      this.voxelModel.setFramebuffer(_Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GPU_FRAMEBUFFER_IDX_0);\r\n      this.voxelModel.drawCombinedFramebuffers(\r\n        currSceneFBIdx, prevSceneFBIdx, \r\n        {mode: _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__[\"default\"].FB1_ALPHA_FB2_ONE_MINUS_ALPHA, alpha: percentFade}\r\n      );\r\n    }\r\n    else {\r\n      await currScene.render(dt);\r\n    }\r\n  }\r\n\r\n  setCrossfadeTime(t) {\r\n    this._totalCrossfadeTime = t;\r\n  }\r\n\r\n  reset() {\r\n    this._sceneMap.forEach(s => s.clear());\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SceneAnimator);\n\n//# sourceURL=webpack:///./src/Animation/SceneAnimator.js?");

/***/ }),

/***/ "./src/Animation/SceneAnimatorDefaultConfigs.js":
/*!******************************************************!*\
  !*** ./src/Animation/SceneAnimatorDefaultConfigs.js ***!
  \******************************************************/
/*! exports provided: SCENE_TYPE_SIMPLE, SCENE_TYPE_SHADOW, SCENE_TYPE_FOG, SCENE_TYPES, sceneAnimatorDefaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCENE_TYPE_SIMPLE\", function() { return SCENE_TYPE_SIMPLE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCENE_TYPE_SHADOW\", function() { return SCENE_TYPE_SHADOW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCENE_TYPE_FOG\", function() { return SCENE_TYPE_FOG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCENE_TYPES\", function() { return SCENE_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sceneAnimatorDefaultConfig\", function() { return sceneAnimatorDefaultConfig; });\n/* harmony import */ var _VoxelTracer_Scenes_SceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VoxelTracer/Scenes/SceneDefaultConfigs */ \"./src/VoxelTracer/Scenes/SceneDefaultConfigs.js\");\n\r\n\r\nconst SCENE_TYPE_SIMPLE  = \"Simple\";\r\nconst SCENE_TYPE_SHADOW  = \"Shadow (Basic)\";\r\nconst SCENE_TYPE_FOG     = \"Fog\";\r\n\r\nconst SCENE_TYPES = [\r\n  SCENE_TYPE_SIMPLE,\r\n  SCENE_TYPE_SHADOW,\r\n  SCENE_TYPE_FOG,\r\n];\r\n\r\nconst sceneAnimatorDefaultConfig = {\r\n  sceneType: SCENE_TYPE_SIMPLE,\r\n  sceneOptions: {..._VoxelTracer_Scenes_SceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_0__[\"simpleSceneDefaultOptions\"]},\r\n};\n\n//# sourceURL=webpack:///./src/Animation/SceneAnimatorDefaultConfigs.js?");

/***/ }),

/***/ "./src/Animation/ShapeWaveAnimator.js":
/*!********************************************!*\
  !*** ./src/Animation/ShapeWaveAnimator.js ***!
  \********************************************/
/*! exports provided: EIGHTIES_COLOUR_PALETTE, RGB_COLOUR_PALETTE, WAVE_SHAPE_CUBE, WAVE_SHAPE_SPHERE, WAVE_SHAPE_TYPES, COLOUR_SELECTION_SEQUENTIAL, COLOUR_SELECTION_RANDOM, COLOUR_SELECTION_TYPES, shapeWaveAnimatorDefaultConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EIGHTIES_COLOUR_PALETTE\", function() { return EIGHTIES_COLOUR_PALETTE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_COLOUR_PALETTE\", function() { return RGB_COLOUR_PALETTE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVE_SHAPE_CUBE\", function() { return WAVE_SHAPE_CUBE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVE_SHAPE_SPHERE\", function() { return WAVE_SHAPE_SPHERE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVE_SHAPE_TYPES\", function() { return WAVE_SHAPE_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_SELECTION_SEQUENTIAL\", function() { return COLOUR_SELECTION_SEQUENTIAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_SELECTION_RANDOM\", function() { return COLOUR_SELECTION_RANDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_SELECTION_TYPES\", function() { return COLOUR_SELECTION_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shapeWaveAnimatorDefaultConfig\", function() { return shapeWaveAnimatorDefaultConfig; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _Randomizers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Randomizers */ \"./src/Animation/Randomizers.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst EIGHTIES_MAGENTA_HEX    = 0xF00078;\r\nconst EIGHTIES_YELLOW_HEX     = 0xFFC70E;\r\nconst EIGHTIES_LIME_HEX       = 0x99FC20;\r\nconst EIGHTIES_PURPLE_HEX     = 0x993F87;\r\nconst EIGHTIES_TEAL_HEX       = 0x1B8772;\r\nconst EIGHTIES_TURQUOISE_HEX  = 0x338F8E;\r\nconst EIGHTIES_CYAN_HEX       = 0x00E6FE;\r\nconst EIGHTIES_STRAWBERRY_HEX = 0xFB2E2B;\r\nconst EIGHTIES_ORANGE_HEX     = 0xFF9933;\r\nconst EIGHTIES_BLUE_HEX       = 0x24739F;\r\n\r\n// Colour Palette Constants\r\nconst EIGHTIES_COLOUR_PALETTE = [\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_MAGENTA_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_TURQUOISE_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_YELLOW_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_LIME_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_TEAL_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_CYAN_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_ORANGE_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_PURPLE_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_STRAWBERRY_HEX),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](EIGHTIES_BLUE_HEX),\r\n];\r\nconst RGB_COLOUR_PALETTE = [\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0xff0000),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0x00ff00),\r\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0x0000ff)\r\n];\r\n\r\n// Wave Shape Constants\r\nconst WAVE_SHAPE_CUBE   = 'cube';\r\nconst WAVE_SHAPE_SPHERE = 'sphere';\r\nconst WAVE_SHAPE_TYPES = [\r\n  WAVE_SHAPE_CUBE,\r\n  WAVE_SHAPE_SPHERE,\r\n];\r\n\r\n// Colour selection constants\r\nconst COLOUR_SELECTION_SEQUENTIAL = 1;\r\nconst COLOUR_SELECTION_RANDOM     = 2;\r\nconst COLOUR_SELECTION_TYPES = [\r\n  COLOUR_SELECTION_SEQUENTIAL,\r\n  COLOUR_SELECTION_RANDOM,\r\n];\r\n\r\nconst shapeWaveAnimatorDefaultConfig = {\r\n  waveShape: WAVE_SHAPE_SPHERE,\r\n  center: {x: 3.5, y: 3.5, z: 3.5},\r\n  waveSpeed: 3, // units / second\r\n  waveGap: 1, // space between waves\r\n  colourPalette: EIGHTIES_COLOUR_PALETTE,\r\n  colourSelectionMode: COLOUR_SELECTION_RANDOM,\r\n  brightness: 1.0,\r\n  repeat: -1, // This needs to be here for the VoxelAnimator setConfig\r\n};\r\n\r\nclass WaveShape {\r\n  constructor(voxelModel, center, shape, colour) {\r\n    this.voxelModel = voxelModel;\r\n    this.center = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](center.x, center.y, center.z);\r\n    this.shape  = shape;\r\n    this.colour = colour;\r\n    this.radius = 0;\r\n    this.lastDrawRadius = 0;\r\n    this.animationFinished = false;\r\n    this.removeMe = false;\r\n  }\r\n\r\n  drawVoxels(drawRadius, brightness) {\r\n    const adjustedColour = this.colour.clone().multiplyScalar(brightness);\r\n    switch (this.shape) {\r\n      case WAVE_SHAPE_CUBE:\r\n        const minPt = this.getMinPt(drawRadius);\r\n        const maxPt = this.getMaxPt(drawRadius);\r\n        this.voxelModel.drawBox(minPt, maxPt, adjustedColour, true);\r\n        break;\r\n      case WAVE_SHAPE_SPHERE:\r\n        this.voxelModel.drawSphere(this.center, drawRadius, adjustedColour, true);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  getMinPt(r) {\r\n    return this.center.clone().subScalar(r);\r\n  }\r\n  getMaxPt(r) {\r\n    return this.center.clone().addScalar(r);\r\n  }\r\n  isInsideVoxels() {\r\n    const voxelGridSize = this.voxelModel.gridSize + 1 + _MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"VOXEL_EPSILON\"];\r\n    const minValue = -(1+_MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"VOXEL_EPSILON\"]);\r\n    const minBoundsPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](minValue, minValue, minValue);\r\n    const maxBoundsPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](voxelGridSize, voxelGridSize, voxelGridSize);\r\n\r\n    switch (this.shape) {\r\n      case WAVE_SHAPE_CUBE:\r\n        const boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"](this.getMinPt(this.radius-1), this.getMaxPt(this.radius-1));\r\n        return !(boundingBox.containsPoint(minBoundsPt) && boundingBox.containsPoint(maxBoundsPt));\r\n      case WAVE_SHAPE_SPHERE:\r\n        const boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__[\"Sphere\"](this.center, this.radius - _MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"VOXEL_EPSILON\"]);\r\n        return !(boundingSphere.containsPoint(minBoundsPt) && boundingSphere.containsPoint(maxBoundsPt));\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  tick(dt, waveSpeed) {\r\n    if (this.animationFinished) {\r\n      return;\r\n    }\r\n    this.radius += dt*waveSpeed;\r\n    if (!this.isInsideVoxels()) {\r\n      this.animationFinished = true;\r\n    }\r\n  }\r\n\r\n  render(dt, waveSpeed, brightness) {\r\n    if (this.animationFinished) {\r\n      return;\r\n    }\r\n\r\n    this.drawVoxels(this.radius, brightness);\r\n    this.radius += dt*waveSpeed;\r\n\r\n    if (!this.isInsideVoxels()) {\r\n      this.animationFinished = true;\r\n    }\r\n  }\r\n};\r\n\r\nclass ShapeWaveAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(voxels, config = shapeWaveAnimatorDefaultConfig) {\r\n    super(voxels, config);\r\n    this.reset();\r\n\r\n    // We define our colour selection based on the selection mode - we load up the colour queue with\r\n    // the configured colour palette and then we pick off the colours that make sense based on the selection mode\r\n    let colourQueue = [];\r\n    this.getNextColour = () => {\r\n      const {colourSelectionMode} = this.config;\r\n      const colourPalette = EIGHTIES_COLOUR_PALETTE; // TODO: Make this dynamically driven from the GUI somehow\r\n\r\n      let nextColour = null;\r\n\r\n      if (colourQueue.length === 0) {\r\n        colourQueue = [...colourPalette];\r\n      }\r\n\r\n      switch (colourSelectionMode) {\r\n\r\n        case COLOUR_SELECTION_RANDOM:\r\n          const randIdx = _Randomizers__WEBPACK_IMPORTED_MODULE_2__[\"Randomizer\"].getRandomInt(0, colourQueue.length);\r\n          nextColour = colourQueue[randIdx];\r\n          colourQueue.splice(randIdx, 1);\r\n          break;\r\n\r\n        case COLOUR_SELECTION_SEQUENTIAL:\r\n        default:\r\n          nextColour = colourQueue.pop();\r\n          break;\r\n      }\r\n\r\n      return nextColour;\r\n    };\r\n\r\n    this.buildWaveShapeAnimator = () => {\r\n      const {center, waveShape} = this.config;\r\n      const currColour = this.getNextColour();\r\n      return new WaveShape(voxels, center, waveShape, currColour);\r\n    };\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"].VOXEL_ANIM_TYPE_SHAPE_WAVES; }\r\n\r\n  setConfig(c) {\r\n    super.setConfig(c);\r\n  }\r\n\r\n  render(dt) {\r\n    const {waveSpeed, waveGap, brightness, waveShape, center} = this.config;\r\n\r\n    const voxelSampleSize = 1 + waveGap;\r\n    const lastShape = this.activeShapes.length > 0 ? this.activeShapes[this.activeShapes.length-1] : null;\r\n    if (!lastShape || lastShape.radius >= voxelSampleSize) {\r\n      this.activeShapes.push(this.buildWaveShapeAnimator());\r\n    }\r\n\r\n    // Build a list of everything we need to render\r\n    const radii = [];\r\n    const colours = [];\r\n    for (let i = this.activeShapes.length-1; i >= 0; i--) {\r\n      const currWaveShape = this.activeShapes[i];\r\n      currWaveShape.tick(dt, waveSpeed);\r\n      radii.push(currWaveShape.radius);\r\n      colours.push(currWaveShape.colour.toArray());\r\n\r\n      if (i > 0) {\r\n        const largerThanCurrentWave = this.activeShapes[i-1];\r\n        if (currWaveShape.animationFinished && largerThanCurrentWave.animationFinished) {\r\n          largerThanCurrentWave.removeMe = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fill the reamining elements (or remove extra elements) in the arrays up to the grid size \r\n    // (this is needed to make the array the same size everytime for the GPU)\r\n    for (let i = radii.length; i < this.voxelModel.gridSize; i++) {\r\n      radii.push(0);\r\n      colours.push([0,0,0]);\r\n    }\r\n    for (let i = radii.length; i > this.voxelModel.gridSize; i--) {\r\n      radii.pop();\r\n      colours.pop();\r\n    }\r\n\r\n    switch (waveShape) {\r\n      case WAVE_SHAPE_CUBE:\r\n        this.voxelModel.drawCubes([center.x, center.y, center.z], radii, colours, brightness);\r\n        break;\r\n      case WAVE_SHAPE_SPHERE:\r\n        this.voxelModel.drawSpheres([center.x, center.y, center.z], radii, colours, brightness);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // Clean up animators that are no longer visible\r\n    this.activeShapes = this.activeShapes.filter((waveShape) => !waveShape.removeMe);\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    this.activeShapes = [];\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShapeWaveAnimator);\n\n//# sourceURL=webpack:///./src/Animation/ShapeWaveAnimator.js?");

/***/ }),

/***/ "./src/Animation/ShootingStarAnimator.js":
/*!***********************************************!*\
  !*** ./src/Animation/ShootingStarAnimator.js ***!
  \***********************************************/
/*! exports provided: shootingStarAnimatorDefaultConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shootingStarAnimatorDefaultConfig\", function() { return shootingStarAnimatorDefaultConfig; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _VoxelColourAnimator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VoxelColourAnimator */ \"./src/Animation/VoxelColourAnimator.js\");\n/* harmony import */ var _Spectrum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Spectrum */ \"./src/Spectrum.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst shootingStarAnimatorDefaultConfig = {\r\n  colour: {r:1, g:1, b:1},\r\n  startPosition: {x:0, y:0, z:7},\r\n  velocity: {x:5, y:0, z:0},\r\n  fadeTimeSecs: 0.75,\r\n  repeat: -1,\r\n};\r\n\r\n/**\r\n * The ShootingStarAnimator will animate a single \"shooting star\", a voxel\r\n * that has a tail which moves from a given starting position in a given\r\n * direction until it has left the display.\r\n */\r\nclass ShootingStarAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(voxels, config = shootingStarAnimatorDefaultConfig) {\r\n    super(voxels, config);\r\n    this.reset();\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"].VOXEL_ANIM_TYPE_SHOOTING_STAR; }\r\n\r\n  setConfig(c) {\r\n    super.setConfig(c);\r\n    const {startPosition, velocity} = c;\r\n\r\n    if (startPosition !== this.startPosition) {\r\n      this.startPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](startPosition.x, startPosition.y, startPosition.z);\r\n    }\r\n    if (startPosition !== this.currPosition) {\r\n      this.currPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](startPosition.x, startPosition.y, startPosition.z);\r\n    }\r\n    if (velocity !== this.velocity) {\r\n      this.velocity = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](velocity.x, velocity.y, velocity.z);\r\n    }\r\n  }\r\n\r\n  addPositionToAnimatorMap(pos) {\r\n    const {colour, fadeTimeSecs} = this.config;\r\n\r\n    // Check to see if the current position has an animator yet...\r\n    for (let i = 0; i < this.currAnimatorMap.length; i++) {\r\n      if (this.currAnimatorMap[i].voxelPosition.distanceToSquared(pos) < _MathUtils__WEBPACK_IMPORTED_MODULE_4__[\"VOXEL_EPSILON\"]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // No animator exists for the given position / voxel, create one.\r\n    const animatorObj = {\r\n      voxelPosition: pos,\r\n      animator: new _VoxelColourAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.voxelModel, {\r\n        voxelPositions: [pos],\r\n        colourStart: colour,\r\n        colourEnd: {r:0, g:0, b:0},\r\n        startTimeSecs: 0.0,\r\n        endTimeSecs: fadeTimeSecs,\r\n        interpolation: _VoxelColourAnimator__WEBPACK_IMPORTED_MODULE_2__[\"INTERPOLATION_SMOOTHER\"],\r\n        colourInterpolationType: _Spectrum__WEBPACK_IMPORTED_MODULE_3__[\"COLOUR_INTERPOLATION_LRGB\"],\r\n      }),\r\n    };\r\n    this.currAnimatorMap.push(animatorObj);\r\n\r\n    return true;\r\n  }\r\n\r\n  rendersToCPUOnly() { return true; }\r\n\r\n  render(dt) {\r\n    if (this.animationFinished) {\r\n      return;\r\n    }\r\n\r\n    super.render(dt);\r\n\r\n    const roundedCurrPos = this.currPosition.clone().round();\r\n    const currPosInBounds = this.voxelModel.isInBounds(this.currPosition);\r\n    if (currPosInBounds) {\r\n      this.addPositionToAnimatorMap(roundedCurrPos);\r\n    }\r\n\r\n    // Animate/tick the active animator objects\r\n    this.currAnimatorMap.forEach((animatorObj) => {\r\n      animatorObj.animator.render(dt);\r\n    });\r\n\r\n    // Clean up all finished animations (only keep the ones that haven't finished and are still in bounds)\r\n    this.currAnimatorMap = this.currAnimatorMap.filter((animatorObj) => {\r\n      return !animatorObj.animator.animationFinished && this.voxelModel.isInBounds(animatorObj.voxelPosition);\r\n    });\r\n\r\n    // Check to see whether this shooting star is finished: \r\n    // i.e., out of bounds, not heading towards the bounds, and has no animations left\r\n    if (this.currAnimatorMap.length === 0 && !currPosInBounds) {\r\n\r\n      const nVelocity = this.velocity.clone().normalize();\r\n      const velocityRay = new three__WEBPACK_IMPORTED_MODULE_0__[\"Ray\"](this.currPosition, nVelocity);\r\n      const voxelsBox = this.voxelModel.getBoundingBox();\r\n\r\n      const target = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n      if (velocityRay.intersectBox(voxelsBox, target) === null) {\r\n        // This loop has finished... check to see if there are repeats\r\n        this.incrementPlayCounter();\r\n        if (this.repeat !== _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"REPEAT_INFINITE_TIMES\"] && this.getPlayCounter() >= this.repeat) {\r\n          this.animationFinished = true;\r\n        }\r\n        else {\r\n          this.resetLoop();\r\n        }\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    const sampleStepSize = _MathUtils__WEBPACK_IMPORTED_MODULE_4__[\"VOXEL_ERR_UNITS\"]; // Sample at a reasonable enough rate\r\n    const sqSampleStepSize = sampleStepSize * sampleStepSize;\r\n    const incVelocity = this.velocity.clone().multiplyScalar(dt);\r\n    const sqLenIncVel = incVelocity.lengthSq();\r\n\r\n    // Perform sampling along the velocity addition in increments equal to a properly sized interval\r\n    // to ensure we don't skip voxels\r\n    if (sqLenIncVel > sqSampleStepSize) {\r\n      const numSamples = Math.floor(incVelocity.length() / sampleStepSize);\r\n      const nVelocity = this.velocity.clone().normalize();\r\n      for (let i = 1; i <= numSamples; i++) {\r\n        const samplePos = this.currPosition.clone().add(nVelocity.clone().multiplyScalar(i*sampleStepSize));\r\n        this.addPositionToAnimatorMap(samplePos.round());\r\n      }\r\n    }\r\n    \r\n    this.currPosition.add(incVelocity);\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    this.resetLoop();\r\n    this.currAnimatorMap = []; // An array of voxel positions to active animators\r\n    this.animationFinished = false;\r\n  }\r\n\r\n  resetLoop() {\r\n    this.currPosition.set(this.startPosition.x, this.startPosition.y, this.startPosition.z);\r\n  }\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShootingStarAnimator);\n\n//# sourceURL=webpack:///./src/Animation/ShootingStarAnimator.js?");

/***/ }),

/***/ "./src/Animation/StarShowerAnimator.js":
/*!*********************************************!*\
  !*** ./src/Animation/StarShowerAnimator.js ***!
  \*********************************************/
/*! exports provided: starShowerDefaultConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"starShowerDefaultConfig\", function() { return starShowerDefaultConfig; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _ShootingStarAnimator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShootingStarAnimator */ \"./src/Animation/ShootingStarAnimator.js\");\n/* harmony import */ var _Randomizers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Randomizers */ \"./src/Animation/Randomizers.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst starShowerDefaultConfig = {\r\n  positionRandomizer: new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"UniformVector3Randomizer\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,7), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](7,7,7)),\r\n  directionRandomizer: new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"Vector3DirectionRandomizer\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,-1), 0),\r\n  speedRandomizer: new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"UniformFloatRandomizer\"](3.0, 8.0), // Speed of a spawned stars in units / second\r\n  colourRandomizer: new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"ColourRandomizer\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,1,0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,1,1)),\r\n  spawnRate: 10.0, // Spawn rate in stars / second\r\n};\r\n\r\n/**\r\n * This class can be thought of as a composition of many shooting stars with\r\n * lots of levers for randomness (where they appear, how fast they move, etc.).\r\n */\r\nclass StarShowerAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(voxels, config = starShowerDefaultConfig) {\r\n    super(voxels, config);\r\n    this.reset();\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"].VOXEL_ANIM_TYPE_STAR_SHOWER; }\r\n\r\n  setConfig(c) {\r\n    super.setConfig(c);\r\n\r\n    // Make sure the config is populated with the appropriate objects\r\n    const {positionRandomizer, directionRandomizer, speedRandomizer, colourRandomizer} = c;\r\n    this.config.positionRandomizer = new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"UniformVector3Randomizer\"](\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](positionRandomizer.min.x, positionRandomizer.min.y, positionRandomizer.min.z),\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](positionRandomizer.max.x, positionRandomizer.max.y, positionRandomizer.max.z)\r\n    );\r\n    this.config.directionRandomizer = new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"Vector3DirectionRandomizer\"](\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](directionRandomizer.baseDirection.x, directionRandomizer.baseDirection.y, directionRandomizer.baseDirection.z), directionRandomizer.radAngle\r\n    );\r\n    this.config.speedRandomizer = new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"UniformFloatRandomizer\"](speedRandomizer.min, speedRandomizer.max);\r\n    this.config.colourRandomizer = new _Randomizers__WEBPACK_IMPORTED_MODULE_3__[\"ColourRandomizer\"](\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colourRandomizer.min.r, colourRandomizer.min.g, colourRandomizer.min.b),\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colourRandomizer.max.r, colourRandomizer.max.g, colourRandomizer.max.b),\r\n    );\r\n    \r\n    this.currSpawnRate = Math.max(1.0, c.spawnRate);\r\n  }\r\n\r\n  rendersToCPUOnly() { return true; }\r\n\r\n  render(dt) {\r\n    // Check whether it's time to spawn a new shooting star\r\n    const spawnTime = (1.0 / this.currSpawnRate);\r\n    while (this.currSpawnTimer >= spawnTime) {\r\n      this.spawnStar();\r\n      this.currSpawnTimer -= spawnTime;\r\n      this.currSpawnCounter++;\r\n      if (this.currSpawnCounter >= this.currSpawnRate) {\r\n        this.currSpawnCounter = 0;\r\n      }\r\n    }\r\n\r\n    // Animate/tick the active shooting star animation objects\r\n    this.activeShootingStars.forEach((animator) => {\r\n      animator.render(dt);\r\n    });\r\n\r\n    // Clean up all finished animations (only keep the ones that haven't finished)\r\n    this.activeShootingStars = this.activeShootingStars.filter((animator) => (!animator.animationFinished));\r\n\r\n    this.currSpawnTimer += dt;\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    this.activeShootingStars = [];\r\n    this.currSpawnCounter = 0;\r\n    this.currSpawnTimer = 0;\r\n  }\r\n\r\n  spawnStar() {\r\n    const {\r\n      positionRandomizer, \r\n      directionRandomizer, \r\n      speedRandomizer, \r\n      colourRandomizer,\r\n    } = this.config;\r\n\r\n    const starPos    = positionRandomizer.generate();\r\n    const starDir    = directionRandomizer.generate();\r\n    const starSpd    = speedRandomizer.generate();\r\n    const starColour = colourRandomizer.generate();\r\n    \r\n    const starConfig = {\r\n      colour: starColour,\r\n      startPosition: starPos,\r\n      velocity: starDir.multiplyScalar(starSpd),\r\n      fadeTimeSecs: 1.5*Math.PI / starSpd,\r\n      repeat: 0,\r\n    };\r\n\r\n    const starAnim = new _ShootingStarAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.voxelModel, starConfig);\r\n    this.activeShootingStars.push(starAnim);\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (StarShowerAnimator);\n\n//# sourceURL=webpack:///./src/Animation/StarShowerAnimator.js?");

/***/ }),

/***/ "./src/Animation/VoxelAnimator.js":
/*!****************************************!*\
  !*** ./src/Animation/VoxelAnimator.js ***!
  \****************************************/
/*! exports provided: REPEAT_INFINITE_TIMES, DEFAULT_CROSSFADE_TIME_SECS, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REPEAT_INFINITE_TIMES\", function() { return REPEAT_INFINITE_TIMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_CROSSFADE_TIME_SECS\", function() { return DEFAULT_CROSSFADE_TIME_SECS; });\nconst REPEAT_INFINITE_TIMES = -1;\r\n\r\nconst VOXEL_ANIM_TYPE_COLOUR        = \"Colour Change\"\r\nconst VOXEL_ANIM_TYPE_SHOOTING_STAR = \"Shooting Star\";\r\nconst VOXEL_ANIM_TYPE_STAR_SHOWER   = \"Star Shower\";\r\nconst VOXEL_ANIM_TYPE_SHAPE_WAVES   = \"Shape Waves\";\r\nconst VOXEL_ANIM_FIRE               = \"Fire\";\r\nconst VOXEL_ANIM_SCENE              = \"Scene\";\r\nconst VOXEL_ANIM_SOUND_VIZ          = \"Visualizer\";\r\n\r\nconst VOXEL_ANIM_TYPES = [\r\n  VOXEL_ANIM_TYPE_COLOUR,\r\n  VOXEL_ANIM_TYPE_SHOOTING_STAR,\r\n  VOXEL_ANIM_TYPE_STAR_SHOWER,\r\n  VOXEL_ANIM_TYPE_SHAPE_WAVES,\r\n  VOXEL_ANIM_FIRE,\r\n  VOXEL_ANIM_SCENE,\r\n  VOXEL_ANIM_SOUND_VIZ,\r\n];\r\n\r\nconst DEFAULT_CROSSFADE_TIME_SECS = 1.0;\r\n\r\nclass VoxelAnimator {\r\n  constructor(voxelModel, config=null) {\r\n\r\n    this.voxelModel = voxelModel;\r\n    this.repeat = 0;\r\n    this.config = {};\r\n    \r\n    let _playCounter = 0;\r\n    this.setPlayCounter = (val) => { _playCounter = val; };\r\n    this.getPlayCounter = () => (_playCounter);\r\n    this.incrementPlayCounter = () => { _playCounter++; };\r\n\r\n    this.setConfig(config);\r\n  }\r\n\r\n  // Constants for various types of animators\r\n  static get VOXEL_ANIM_TYPE_COLOUR() {return VOXEL_ANIM_TYPE_COLOUR;}\r\n  static get VOXEL_ANIM_TYPE_SHOOTING_STAR() {return VOXEL_ANIM_TYPE_SHOOTING_STAR;}\r\n  static get VOXEL_ANIM_TYPE_STAR_SHOWER() {return VOXEL_ANIM_TYPE_STAR_SHOWER;}\r\n  static get VOXEL_ANIM_TYPE_SHAPE_WAVES() {return VOXEL_ANIM_TYPE_SHAPE_WAVES;}\r\n  static get VOXEL_ANIM_FIRE() {return VOXEL_ANIM_FIRE;}\r\n  static get VOXEL_ANIM_SCENE() {return VOXEL_ANIM_SCENE;}\r\n  static get VOXEL_ANIM_SOUND_VIZ() {return VOXEL_ANIM_SOUND_VIZ;}\r\n\r\n  static get VOXEL_ANIM_TYPES() {return VOXEL_ANIM_TYPES;}\r\n\r\n  getType() { return null; }\r\n  \r\n\r\n  setConfig(c) {\r\n    this.config = c ? c : {};\r\n    const {repeat} = this.config;\r\n    if (repeat) {\r\n      this.repeat = repeat;\r\n    }\r\n  }\r\n\r\n  render(dt) {}\r\n  rendersToCPUOnly() { return false; }\r\n\r\n  reset() {\r\n    this.setPlayCounter(0);\r\n  }\r\n  stop() {}\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VoxelAnimator);\n\n//# sourceURL=webpack:///./src/Animation/VoxelAnimator.js?");

/***/ }),

/***/ "./src/Animation/VoxelColourAnimator.js":
/*!**********************************************!*\
  !*** ./src/Animation/VoxelColourAnimator.js ***!
  \**********************************************/
/*! exports provided: INTERPOLATION_LERP, INTERPOLATION_SMOOTH, INTERPOLATION_SMOOTHER, INTERPOLATION_TYPES, voxelColourAnimatorDefaultConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INTERPOLATION_LERP\", function() { return INTERPOLATION_LERP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INTERPOLATION_SMOOTH\", function() { return INTERPOLATION_SMOOTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INTERPOLATION_SMOOTHER\", function() { return INTERPOLATION_SMOOTHER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INTERPOLATION_TYPES\", function() { return INTERPOLATION_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"voxelColourAnimatorDefaultConfig\", function() { return voxelColourAnimatorDefaultConfig; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ \"chroma-js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _Spectrum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Spectrum */ \"./src/Spectrum.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst INTERPOLATION_LERP     = 'lerp';\r\nconst INTERPOLATION_SMOOTH   = 'smooth';\r\nconst INTERPOLATION_SMOOTHER = 'smoother';\r\nconst INTERPOLATION_TYPES = [\r\n  INTERPOLATION_LERP,\r\n  INTERPOLATION_SMOOTH,\r\n  INTERPOLATION_SMOOTHER,\r\n];\r\n\r\nconst voxelColourAnimatorDefaultConfig = {\r\n  voxelPositions: [{x:0, y:0, z:0}],\r\n  colourStart: {r:0, g:0, b:0},\r\n  colourEnd: {r:1, g:1, b:1},\r\n  colourInterpolationType: _Spectrum__WEBPACK_IMPORTED_MODULE_4__[\"COLOUR_INTERPOLATION_RGB\"],\r\n  interpolationType: INTERPOLATION_LERP,\r\n  startTimeSecs: 0.0,\r\n  endTimeSecs: 10.0,\r\n  repeat: 0,\r\n};\r\n\r\nclass VoxelColourAnimator extends _VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n  constructor(voxels, config = voxelColourAnimatorDefaultConfig) {\r\n    super(voxels, config);\r\n    this.reset();\r\n  }\r\n\r\n  getType() { return _VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_TYPE_COLOUR; }\r\n\r\n  setConfig(c) {\r\n    super.setConfig(c);\r\n    const {voxelPositions, colourStart, colourEnd} = c;\r\n\r\n    if (voxelPositions !== this.voxelPositions) {\r\n      this.voxelPositions = voxelPositions.map(value => new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](value.x, value.y, value.z));\r\n    }\r\n    if (colourStart !== this.colourStart) {\r\n      this.colourStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colourStart.r, colourStart.g, colourStart.b);\r\n    }\r\n    if (colourEnd !== this.colourEnd) {\r\n      this.colourEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colourEnd.r, colourEnd.g, colourEnd.b);\r\n    }\r\n  }\r\n\r\n  rendersToCPUOnly() { return true; }\r\n\r\n  render(dt) {\r\n    super.render(dt);\r\n\r\n    const {startTimeSecs, endTimeSecs, colourInterpolationType, interpolationType} = this.config;\r\n\r\n    let dtRemaining = dt;\r\n    if (this.currTime >= startTimeSecs) {\r\n      \r\n      let interpolateAlpha = 0;\r\n      switch (interpolationType) {\r\n        default:\r\n        case INTERPOLATION_LERP:\r\n          interpolateAlpha = (this.currTime - startTimeSecs) / (endTimeSecs - startTimeSecs);\r\n          break;\r\n        case INTERPOLATION_SMOOTH:\r\n          interpolateAlpha = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smoothstep(this.currTime, startTimeSecs, endTimeSecs);\r\n          break;\r\n        case INTERPOLATION_SMOOTHER:\r\n          interpolateAlpha = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smootherstep(this.currTime, startTimeSecs, endTimeSecs);\r\n          break;\r\n      }\r\n      \r\n      const temp = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.colourStart), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.colourEnd), interpolateAlpha, colourInterpolationType).gl();\r\n      const currColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](temp[0], temp[1], temp[2]);\r\n      \r\n      this.voxelPositions.forEach(voxelPos => {\r\n        this.voxelModel.drawPoint(voxelPos, currColour);\r\n      });\r\n\r\n      const isFinishedCurrentLoop = (this.currTime >= endTimeSecs);\r\n      if (isFinishedCurrentLoop) {\r\n        this.incrementPlayCounter();\r\n        if (this.repeat !== _VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"REPEAT_INFINITE_TIMES\"] && this.getPlayCounter() >= this.repeat) {\r\n          this.animationFinished = true;\r\n        }\r\n        else {\r\n          // Find out how much time spilled over into the next animation before resetting the loop\r\n          dtRemaining = dt - (endTimeSecs - this.currTime);\r\n          this.resetLoop();\r\n        }\r\n      }\r\n    }\r\n\r\n    this.currTime = Math.min(endTimeSecs, this.currTime + dtRemaining); // Clamp to the end time\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    this.resetLoop();\r\n    this.animationFinished = false;\r\n  }\r\n\r\n  resetLoop() {\r\n    this.currTime = 0;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VoxelColourAnimator);\n\n//# sourceURL=webpack:///./src/Animation/VoxelColourAnimator.js?");

/***/ }),

/***/ "./src/Fluid.js":
/*!**********************!*\
  !*** ./src/Fluid.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst NUM_BUFFERS = 10;\r\n\r\nclass Fluid {\r\n  constructor(gridSize) {\r\n    this.N = gridSize;\r\n    this.SIZE = Math.pow(this.N+2,3);\r\n\r\n    // Initialize the array of buffers\r\n    this.buffers = [];\r\n    for (let i = 0; i < NUM_BUFFERS; i++) {\r\n      this.buffers.push(new Array(this.SIZE).fill(0));\r\n    }\r\n\r\n    // Source buffers for density and velocities\r\n    this.sd = new Array(this.SIZE).fill(0);\r\n    this.su = new Array(this.SIZE).fill(0);\r\n    this.sv = new Array(this.SIZE).fill(0);\r\n    this.sw = new Array(this.SIZE).fill(0);\r\n    this.sT = new Array(this.SIZE).fill(0);\r\n\r\n    this.diffusion = 0;\r\n    this.viscosity = 0;\r\n    this.cooling   = 0;\r\n    this.buoyancy  = 0;\r\n    this.vc_eps    = 0;\r\n\r\n    this.d = this.buffers[0]; this.d0 = this.buffers[1]; // density\r\n    this.T = this.buffers[2]; this.T0 = this.buffers[3]; // temperature\r\n    this.u = this.buffers[4]; this.u0 = this.buffers[5]; // velocity in the x direction\r\n    this.v = this.buffers[6]; this.v0 = this.buffers[7]; // velocity in the y direction\r\n    this.w = this.buffers[8]; this.w0 = this.buffers[9]; // velocity in the z direction\r\n\r\n    for (let i = 0; i < this.SIZE; i++) {\r\n      this.v[i] = 0.5; // fire goes up!\r\n    }\r\n  }\r\n\r\n  _I(x,y,z) {\r\n    return z*Math.pow(this.N+2,2) + y*(this.N+2) + x;\r\n  }\r\n\r\n  //set_bnd(b, x) {}\r\n\r\n  addSource(srcBuffer, dstBuffer, dt) {\r\n    for (let i = 0; i < this.SIZE; i++) {\r\n      dstBuffer[i] += srcBuffer[i] * dt;\r\n    }\r\n  }\r\n\r\n  addBuoyancy(dt) {\r\n    for (let i = 0; i < this.SIZE; i++) {\r\n      this.v[i] += this.T[i] * this.buoyancy * dt;\r\n    }\r\n  }\r\n\r\n  diffuse(b, x0, x, diff, dt) {\r\n    let a = dt * diff * this.N * this.N * this.N;\r\n    for (let l = 0; l < 20; l++) {\r\n      for (let k = 1; k <= this.N; k++) {\r\n        for (let j = 1; j <= this.N; j++) {\r\n          for (let i = 1; i <= this.N; i++) {\r\n            x[this._I(i,j,k)] = (x0[this._I(i,j,k)] + a*(\r\n              x[this._I(i-1,j,k)] + x[this._I(i+1,j,k)] +\r\n              x[this._I(i,j-1,k)] + x[this._I(i,j+1,k)] +\r\n              x[this._I(i,j,k-1)] + x[this._I(i,j,k+1)]\r\n            )) / (1+6*a);\r\n          }\r\n        }\r\n      }\r\n      //this.set_bnd(b, x);\r\n    }\r\n  }\r\n\r\n  advect(b, x0, x, uu, vv, ww, dt) {\r\n    const dt0 = dt*this.N;\r\n    for (let k = 1; k <= this.N; k++) {\r\n      for (let j = 1; j <= this.N; j++) {\r\n        for (let i = 1; i <= this.N; i++) {\r\n          let xx = i-dt0*uu[this._I(i,j,k)];\r\n          let yy = j-dt0*vv[this._I(i,j,k)];\r\n          let zz = k-dt0*ww[this._I(i,j,k)];\r\n\r\n          if (xx < 0.5) { xx = 0.5; } if (xx > this.N+0.5) { xx = this.N + 0.5; } let i0 = parseInt(xx); let i1 = i0 + 1;\r\n          if (yy < 0.5) { yy = 0.5; } if (yy > this.N+0.5) { yy = this.N + 0.5; } let j0 = parseInt(yy); let j1 = j0 + 1;\r\n          if (zz < 0.5) { zz = 0.5; } if (zz > this.N+0.5) { zz = this.N + 0.5; } let k0 = parseInt(zz); let k1 = k0 + 1;\r\n\r\n          let sx1 = xx-i0; let sx0 = 1-sx1;\r\n          let sy1 = yy-j0; let sy0 = 1-sy1;\r\n          let sz1 = zz-k0; let sz0 = 1-sz1;\r\n\r\n          let v0 = sx0*(sy0*x0[this._I(i0,j0,k0)] + sy1*x0[this._I(i0,j1,k0)]) + sx1*(sy0*x0[this._I(i1,j0,k0)]+sy1*x0[this._I(i1,j1,k0)]);\r\n          let v1 = sx0*(sy0*x0[this._I(i0,j0,k1)] + sy1*x0[this._I(i0,j1,k1)]) + sx1*(sy0*x0[this._I(i1,j0,k1)]+sy1*x0[this._I(i1,j1,k1)]);\r\n          x[this._I(i,j,k)] = sz0*v0 + sz1*v1;\r\n        }\r\n      }\r\n    }\r\n    //this.set_bnd(b, this.d);\r\n  }\r\n\r\n  advectCool(b, x0, x, y0, y, uu, vv, ww, dt) {\r\n    const dt0 = dt*this.N;\r\n    const c0 = 1.0 - this.cooling*dt;\r\n\r\n    for (let k = 1; k <= this.N; k++) {\r\n      for (let j = 1; j <= this.N; j++) {\r\n        for (let i = 1; i <= this.N; i++) {\r\n          let xx = i-dt0*uu[this._I(i,j,k)];\r\n          let yy = j-dt0*vv[this._I(i,j,k)];\r\n          let zz = k-dt0*ww[this._I(i,j,k)];\r\n\r\n          if (xx < 0.5) { xx = 0.5; } if (xx > this.N+0.5) { xx = this.N + 0.5; } let i0 = parseInt(xx); let i1 = i0 + 1;\r\n          if (yy < 0.5) { yy = 0.5; } if (yy > this.N+0.5) { yy = this.N + 0.5; } let j0 = parseInt(yy); let j1 = j0 + 1;\r\n          if (zz < 0.5) { zz = 0.5; } if (zz > this.N+0.5) { zz = this.N + 0.5; } let k0 = parseInt(zz); let k1 = k0 + 1;\r\n\r\n          let sx1 = xx-i0; let sx0 = 1-sx1;\r\n          let sy1 = yy-j0; let sy0 = 1-sy1;\r\n          let sz1 = zz-k0; let sz0 = 1-sz1;\r\n\r\n          let v0 = sx0*(sy0*x0[this._I(i0,j0,k0)] + sy1*x0[this._I(i0,j1,k0)]) + sx1*(sy0*x0[this._I(i1,j0,k0)]+sy1*x0[this._I(i1,j1,k0)]);\r\n          let v1 = sx0*(sy0*x0[this._I(i0,j0,k1)] + sy1*x0[this._I(i0,j1,k1)]) + sx1*(sy0*x0[this._I(i1,j0,k1)]+sy1*x0[this._I(i1,j1,k1)]);\r\n          x[this._I(i,j,k)] = sz0*v0 + sz1*v1;\r\n\r\n          v0 = sx0*(sy0*y0[this._I(i0,j0,k0)] + sy1*y0[this._I(i0,j1,k0)]) + sx1*(sy0*y0[this._I(i1,j0,k0)]+sy1*y0[this._I(i1,j1,k0)]);\r\n          v1 = sx0*(sy0*y0[this._I(i0,j0,k1)] + sy1*y0[this._I(i0,j1,k1)]) + sx1*(sy0*y0[this._I(i1,j0,k1)]+sy1*y0[this._I(i1,j1,k1)]);\r\n          y[this._I(i,j,k)] = (sz0*v0 + sz1*v1)*c0;\r\n        }\r\n      }\r\n    }\r\n    //this.set_bnd(b, this.d);\r\n  }\r\n\r\n  project() {\r\n    const p = this.u0;\r\n    const div = this.v0;\r\n    const h = 1.0/this.N;\r\n    for (let k = 1; k <= this.N; k++) {\r\n      for (let j = 1; j <= this.N; j++) {\r\n        for (let i = 1; i <= this.N; i++) {\r\n          div[this._I(i,j,k)] = -h*(\r\n            this.u[this._I(i+1,j,k)] - this.u[this._I(i-1,j,k)] +\r\n            this.v[this._I(i,j+1,k)] - this.v[this._I(i,j-1,k)] +\r\n            this.w[this._I(i,j,k+1)] - this.w[this._I(i,j,k-1)])/3;\r\n          \r\n          p[this._I(i,j,k)] = 0;\r\n        }\r\n      }\r\n    }\r\n    //this.set_bnd(0, div);\r\n    //this.set_bnd(0, p);\r\n\r\n    for (let l = 0; l < 20; l++) {\r\n      for (let k = 1; k <= this.N; k++) {\r\n        for (let j = 1; j <= this.N; j++) {\r\n          for (let i = 1; i <= this.N; i++) {\r\n            p[this._I(i,j,k)] = (div[this._I(i,j,k)] +\r\n              p[this._I(i-1,j,k)] + p[this._I(i+1,j,k)] +\r\n              p[this._I(i,j-1,k)] + p[this._I(i,j+1,k)] +\r\n              p[this._I(i,j,k-1)] + p[this._I(i,j,k+1)])/6;\r\n          }\r\n        }\r\n      }\r\n      //this.set_bnd(0, p);\r\n    }\r\n\r\n    for (let k = 1; k <= this.N; k++) {\r\n      for (let j = 1; j <= this.N; j++) {\r\n        for (let i = 1; i <= this.N; i++) {\r\n          this.u[this._I(i,j,k)] -= (p[this._I(i+1,j,k)] - p[this._I(i-1,j,k)])/3/h;\r\n          this.v[this._I(i,j,k)] -= (p[this._I(i,j+1,k)] - p[this._I(i,j-1,k)])/3/h;\r\n          this.w[this._I(i,j,k)] -= (p[this._I(i,j,k+1)] - p[this._I(i,j,k-1)])/3/h;\r\n        }\r\n      }\r\n    }\r\n    //this.set_bnd(1, this.u);\r\n    //this.set_bnd(2, this.v);\r\n  }\r\n\r\n  vorticityConfinement(dt) {\r\n    const curlx = this.u0; const curly = this.v0; const curlz = this.w0; const curl = this.T0;\r\n    const dt0 = dt * this.vc_eps;\r\n\r\n    for (let k = 1; k < this.N; k++) {\r\n      for (let j = 1; j < this.N; j++) {\r\n        for (let i = 1; i < this.N; i++) {\r\n          let ijk = this._I(i,j,k);\r\n\r\n          let x = curlx[ijk] = (this.w[this._I(i,j+1,k)] - this.w[this._I(i,j-1,k)]) * 0.5 -\r\n            (this.v[this._I(i,j,k+1)] - this.v[this._I(i,j,k-1)]) * 0.5;\r\n          let y = curly[ijk] = (this.u[this._I(i,j,k+1)] - this.u[this._I(i,j,k-1)]) * 0.5 -\r\n            (this.w[this._I(i+1,j,k)] - this.w[this._I(i-1,j,k)]) * 0.5;\r\n          let z = curlz[ijk] = (this.v[this._I(i+1,j,k)] - this.v[this._I(i-1,j,k)]) * 0.5 -\r\n            (this.u[this._I(i,j+1,k)] - this.u[this._I(i,j-1,k)]) * 0.5;\r\n\r\n          curl[ijk] = Math.sqrt(x*x + y*y + z*z);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let k = 1; k < this.N; k++) {\r\n      for (let j = 1; j < this.N; j++) {\r\n        for (let i = 1; i < this.N; i++) {\r\n          let ijk = this._I(i,j,k);\r\n\r\n          let Nx = (curl[this._I(i+1,j,k)] - curl[this._I(i-1,j,k)]) * 0.5;\r\n          let Ny = (curl[this._I(i,j+1,k)] - curl[this._I(i,j-1,k)]) * 0.5;\r\n          let Nz = (curl[this._I(i,j,k+1)] - curl[this._I(i,j,k-1)]) * 0.5;\r\n          let len1 = 1.0 / (Math.sqrt(Nx*Nx + Ny*Ny + Nz*Nz) + 0.0000001);\r\n          Nx *= len1;\r\n          Ny *= len1;\r\n          Nz *= len1;\r\n\r\n          this.u[ijk] += (Ny*curlz[ijk] - Nz*curly[ijk]) * dt0;\r\n          this.v[ijk] += (Nz*curlx[ijk] - Nx*curlz[ijk]) * dt0;\r\n          this.w[ijk] += (Nx*curly[ijk] - Ny*curlx[ijk]) * dt0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  velStep(dt, diffuse = true, advect = true) {\r\n\r\n    this.addSource(this.su, this.u, dt);\r\n    this.addSource(this.sv, this.v, dt);\r\n    this.addSource(this.sw, this.w, dt);\r\n    this.addBuoyancy(dt);\r\n    this.vorticityConfinement(dt);\r\n\r\n    let temp = null;\r\n\r\n    if (diffuse) {\r\n      temp = this.u; this.u = this.u0; this.u0 = temp;\r\n      temp = this.v; this.v = this.v0; this.v0 = temp;\r\n      temp = this.w; this.w = this.w0; this.w0 = temp;\r\n      this.diffuse(1, this.u0, this.u, this.viscosity, dt);\r\n      this.diffuse(2, this.v0, this.v, this.viscosity, dt);\r\n      this.diffuse(3, this.w0, this.w, this.viscosity, dt);\r\n      this.project();\r\n    }\r\n\r\n    if (advect) {\r\n      temp = this.u; this.u = this.u0; this.u0 = temp;\r\n      temp = this.v; this.v = this.v0; this.v0 = temp;\r\n      temp = this.w; this.w = this.w0; this.w0 = temp;\r\n      this.advect(1, this.u0, this.u, this.u0, this.v0, this.w0, dt);\r\n      this.advect(2, this.v0, this.v, this.u0, this.v0, this.w0, dt);\r\n      this.advect(3, this.w0, this.w, this.u0, this.v0, this.w0, dt);\r\n      this.project();\r\n    }\r\n  }\r\n\r\n  densStep(dt, diffuse = true, advect = true) {\r\n    this.addSource(this.sd, this.d, dt);\r\n    let temp = null;\r\n    if (diffuse) {\r\n      temp = this.d; this.d = this.d0; this.d0 = temp;\r\n      this.diffuse(0, this.d0, this.d, this.diffusion, dt);\r\n    }\r\n    if (advect) {\r\n      temp = this.d; this.d = this.d0; this.d0 = temp;\r\n      this.advect(0, this.d0, this.d, this.u, this.v, this.w, dt);\r\n    }\r\n  }\r\n\r\n  densTempStep(dt) {\r\n    this.addSource(this.sd, this.d, dt);\r\n    this.addSource(this.sT, this.T, dt);\r\n    \r\n    let temp = null;\r\n    temp = this.d; this.d = this.d0; this.d0 = temp;\r\n    this.diffuse(0, this.d0, this.d, this.diffusion, dt);\r\n    temp = this.d; this.d = this.d0; this.d0 = temp;\r\n    temp = this.T; this.T = this.T0; this.T0 = temp;\r\n    this.advectCool(0, this.d0, this.d, this.T0, this.T, this.u, this.v, this.w, dt);\r\n  }\r\n\r\n  step(dt) {\r\n    this.velStep(dt);\r\n    this.densTempStep(dt);\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Fluid);\n\n//# sourceURL=webpack:///./src/Fluid.js?");

/***/ }),

/***/ "./src/MathUtils.js":
/*!**************************!*\
  !*** ./src/MathUtils.js ***!
  \**************************/
/*! exports provided: VOXEL_EPSILON, VOXEL_ERR_UNITS, SQRT3, SQRT2PI, PI2, hslToHsvColor, hsvToHslColor, clamp, hashCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VOXEL_EPSILON\", function() { return VOXEL_EPSILON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VOXEL_ERR_UNITS\", function() { return VOXEL_ERR_UNITS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SQRT3\", function() { return SQRT3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SQRT2PI\", function() { return SQRT2PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PI2\", function() { return PI2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hslToHsvColor\", function() { return hslToHsvColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsvToHslColor\", function() { return hsvToHslColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hashCode\", function() { return hashCode; });\nconst VOXEL_EPSILON = 0.00001;\r\nconst VOXEL_ERR_UNITS = 1.0 / (2.0 + VOXEL_EPSILON);\r\n\r\nconst SQRT3   = 1.73205080757;\r\nconst SQRT2PI = 4.44288293816;\r\nconst PI2 = Math.PI*2;\r\n\r\nconst hslToHsvColor = (hsl) => {\r\n  const v = hsl.l + hsl.s*Math.min(hsl.l,1-hsl.l);\r\n  return {h:hsl.h, s: v == 0 ? 0 : 2-2*hsl.l/v, v:v};\r\n}\r\nconst hsvToHslColor = (hsv) => {\r\n  const l = hsv.v - hsv.v*hsv.s/2.0;\r\n  const hsl = new THREE.Color();\r\n  hsl.setHSL(hsv.h, l === 0 || l === 1 ? 0 : ((hsv.v-l)/Math.min(l,1-l)), l);\r\n}\r\n\r\nconst clamp = (value, min, max) => {\r\n  return Math.max(min, Math.min(max, value));\r\n}\r\n\r\n/**\r\n * Fast hash code function for uint8 arrays.\r\n * @param {Uint8Array} arr - Array to get the hash code for.\r\n */\r\nconst hashCode = (arr) => {\r\n  let hash = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    hash = ((hash << 5) - hash) + arr[i];\r\n    hash = hash & hash;\r\n  }\r\n  return hash;\r\n}\n\n//# sourceURL=webpack:///./src/MathUtils.js?");

/***/ }),

/***/ "./src/Server/GPUKernelManager.js":
/*!****************************************!*\
  !*** ./src/Server/GPUKernelManager.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var gpu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gpu.js */ \"gpu.js\");\n/* harmony import */ var gpu_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gpu_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Spectrum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Spectrum */ \"./src/Spectrum.js\");\n\r\n\r\n\r\n\r\n\r\nclass GPUKernelManager {\r\n  constructor(gridSize) {\r\n    this.gpu = new gpu_js__WEBPACK_IMPORTED_MODULE_0__[\"GPU\"]({mode: 'headlessgl'});;\r\n\r\n    this.gpu.addFunction(function clampValue(value, min, max) {\r\n      return Math.min(max, Math.max(min, value));\r\n    });\r\n\r\n    this.pipelineFuncSettings = {\r\n      output: [gridSize, gridSize, gridSize],\r\n      pipeline: true, // We use pipelining for most things in order to get a texture output from kernels\r\n      constants: {\r\n        VOXEL_ERR_UNITS_SQR: _MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_ERR_UNITS\"]*_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_ERR_UNITS\"],\r\n        gridSize: gridSize,\r\n        halfGridSize: gridSize/2,\r\n      },\r\n      returnType: 'Array(3)',\r\n      immutable: false,\r\n    };\r\n    const immutable = false;\r\n\r\n    // Setup the GPU/Compute kernels...\r\n\r\n    // Utility kernels\r\n    this.clearFunc = this.gpu.createKernel(function(colour) {\r\n      return [colour[0], colour[1], colour[2]];\r\n    }, {...this.pipelineFuncSettings, immutable: false, argumentTypes: {colour: 'Array(3)'}});\r\n\r\n    this.multiplyColourFunc = this.gpu.createKernel(function(pipelineTex, colour) {\r\n      const currVoxel = pipelineTex[this.thread.z][this.thread.y][this.thread.x];\r\n      return [currVoxel[0]*colour[0], currVoxel[1]*colour[1], currVoxel[2]*colour[2]];\r\n    }, {...this.pipelineFuncSettings, argumentTypes: {pipelineTex: 'Array3D(3)', colour: 'Array(3)'}});\r\n\r\n    // Framebuffer combination kernels\r\n    this.addFramebuffersFunc = this.gpu.createKernel(function(framebufTexA, framebufTexB) {\r\n      const fbAVoxel = framebufTexA[this.thread.z][this.thread.y][this.thread.x];\r\n      const fbBVoxel = framebufTexB[this.thread.z][this.thread.y][this.thread.x];\r\n      return [clampValue(fbAVoxel[0]+fbBVoxel[0], 0.0, 1.0), clampValue(fbAVoxel[1]+fbBVoxel[1], 0.0, 1.0), clampValue(fbAVoxel[2]+fbBVoxel[2], 0.0, 1.0)];\r\n    }, {...this.pipelineFuncSettings, immutable: immutable, argumentTypes: {framebufTexA: 'Array3D(3)', framebufTexB: 'Array3D(3)'}});\r\n\r\n    this.copyFramebufferFunc = this.gpu.createKernel(function(framebufTex) {\r\n      return framebufTex[this.thread.z][this.thread.y][this.thread.x];\r\n    }, {...this.pipelineFuncSettings, immutable: false, argumentTypes: {framebufTex: 'Array3D(3)'}});\r\n    \r\n    this.copyFramebufferFuncImmutable = this.gpu.createKernel(function(framebufTex) {\r\n      return framebufTex[this.thread.z][this.thread.y][this.thread.x];\r\n    }, {...this.pipelineFuncSettings, immutable: true, argumentTypes: {framebufTex: 'Array3D(3)'}});\r\n    \r\n    this.combineFramebuffersAlphaOneMinusAlphaFunc = this.gpu.createKernel(function(fb1Tex, fb2Tex, alpha, oneMinusAlpha) {\r\n      const fb1Voxel = fb1Tex[this.thread.z][this.thread.y][this.thread.x];\r\n      const fb2Voxel = fb2Tex[this.thread.z][this.thread.y][this.thread.x];\r\n      return [\r\n        alpha*fb1Voxel[0] + oneMinusAlpha*fb2Voxel[0],\r\n        alpha*fb1Voxel[1] + oneMinusAlpha*fb2Voxel[1],\r\n        alpha*fb1Voxel[2] + oneMinusAlpha*fb2Voxel[2]\r\n      ];\r\n    }, {...this.pipelineFuncSettings, immutable: immutable, argumentTypes: {fb1Tex: 'Array3D(3)', fb2Tex: 'Array3D(3)', alpha: 'Float', oneMinusAlpha: 'Float'}});\r\n\r\n    // Animation-specific Kernels\r\n    /*\r\n    this.boxFillMaskFunc = this.gpu.createKernel(function(minPt, maxPt) {\r\n      const currVoxelPos = [this.thread.z, this.thread.y, this.thread.x];\r\n      return (currVoxelPos[0] > minPt[0] && currVoxelPos[0] < maxPt[0] &&\r\n              currVoxelPos[1] > minPt[1] && currVoxelPos[1] < maxPt[1] &&\r\n              currVoxelPos[2] > minPt[2] && currVoxelPos[2] < maxPt[2]) \r\n          ? [1.0, 1.0, 1.0] : [0.0, 0.0, 0.0];\r\n    }, this.pipelineFuncSettings);\r\n    this.boxOutlineMaskFunc = this.gpu.createKernel(function(minPt, maxPt) {\r\n      const currVoxelPos = [this.thread.z, this.thread.y, this.thread.x];\r\n      // Is the voxel within the outer boundary voxels of the box?\r\n      const dx = Math.max(Math.max(minPt[0] - currVoxelPos[0], 0), currVoxelPos[0] - maxPt[0]);\r\n      const dy = Math.max(Math.max(minPt[1] - currVoxelPos[1], 0), currVoxelPos[1] - maxPt[1]);\r\n      const dz = Math.max(Math.max(minPt[2] - currVoxelPos[2], 0), currVoxelPos[2] - maxPt[2]);\r\n      const sqrDist = dx*dx + dy*dy + dz*dz;\r\n      return (sqrDist < this.constants.VOXEL_ERR_UNITS_SQR) ? [1.0, 1.0, 1.0] : [0.0, 0.0, 0.0];\r\n    }, this.pipelineFuncSettings);\r\n    this.sphereOutlineMaskFunc = this.gpu.createKernel(function(c, rSqr) {\r\n      // Check whether the voxel is on the outside-ish of the sphere\r\n      const currVoxelPos = [this.thread.z, this.thread.y, this.thread.x];\r\n      // Find the squared distance from the center of the sphere to the voxel\r\n      const sqrDist = Math.pow(currVoxelPos[0]-c[0],2) + Math.pow(currVoxelPos[1]-c[1],2) + Math.pow(currVoxelPos[2]-c[2],2);\r\n      return Math.abs(rSqr-sqrDist) <= this.constants.VOXEL_ERR_UNITS_SQR ?  [1.0, 1.0, 1.0]  : [0.0, 0.0, 0.0];\r\n    }, this.pipelineFuncSettings);\r\n    this.overwriteMaskedColourFuncImmutable = this.gpu.createKernel(function(framebufTex, maskTex, colour) {\r\n      const originalVoxel = framebufTex[this.thread.z][this.thread.y][this.thread.x];\r\n      const maskVoxel  = maskTex[this.thread.z][this.thread.y][this.thread.x];\r\n      return maskVoxel[0] <= 0 ? [originalVoxel[0], originalVoxel[1], originalVoxel[2]] : [colour[0], colour[1], colour[2]];\r\n    }, {...this.pipelineFuncSettings, immutable: true, argumentTypes: {framebufTex: 'Array3D(3)', maskTex: 'Array3D(3)', colour: 'Array(3)'}});\r\n    */\r\n\r\n    const shapesDrawSettings = {...this.pipelineFuncSettings, \r\n      immutable: immutable, \r\n      argumentTypes: {\r\n        framebufTex: 'Array3D(3)', c: 'Array(3)', radiiSqr: 'Array', colours: 'Array1D(3)', brightness: 'Float', numSpheres: 'Integer'\r\n      }\r\n    }\r\n    this.spheresFillOverwrite = this.gpu.createKernel(function(framebufTex, c, radiiSqr, colours, brightness) {\r\n      // Find the squared distance from the center of the sphere to the voxel\r\n      const currVoxelPos = [this.thread.z, this.thread.y, this.thread.x];\r\n      const framebufColour = framebufTex[this.thread.z][this.thread.y][this.thread.x];\r\n      const sqrDist = Math.pow(currVoxelPos[0]-c[0],2) + Math.pow(currVoxelPos[1]-c[1],2) + Math.pow(currVoxelPos[2]-c[2],2);\r\n      \r\n      // Check each radius to see which one the voxel is inside last\r\n      for (let i = 0; i < this.constants.gridSize; i++) {\r\n        if (sqrDist <= (radiiSqr[i] + this.constants.VOXEL_ERR_UNITS_SQR)) {\r\n          const currColour = colours[i];\r\n          return [brightness*currColour[0], brightness*currColour[1], brightness*currColour[2]];\r\n        }\r\n      }\r\n      return [framebufColour[0], framebufColour[1], framebufColour[2]];\r\n    }, shapesDrawSettings);\r\n\r\n    this.cubesFillOverwrite = this.gpu.createKernel(function(framebufTex, c, radii, colours, brightness) {\r\n      // Find the squared distance from the center of the sphere to the voxel\r\n      const currVoxelPos = [this.thread.z, this.thread.y, this.thread.x];\r\n      const framebufColour = framebufTex[this.thread.z][this.thread.y][this.thread.x];\r\n\r\n      // Check each radius to see which one the voxel is inside last\r\n      for (let i = 0; i < this.constants.gridSize; i++) {\r\n        const radius = radii[i];\r\n        const minPt = [c[0]-radius, c[1]-radius, c[2]-radius];\r\n        const maxPt = [c[0]+radius, c[1]+radius, c[2]+radius];\r\n        if (currVoxelPos[0] > minPt[0] && currVoxelPos[0] < maxPt[0] &&\r\n            currVoxelPos[1] > minPt[1] && currVoxelPos[1] < maxPt[1] &&\r\n            currVoxelPos[2] > minPt[2] && currVoxelPos[2] < maxPt[2]) {\r\n\r\n          const currColour = colours[i];\r\n          return [brightness*currColour[0], brightness*currColour[1], brightness*currColour[2]];\r\n        }\r\n      }\r\n      return [framebufColour[0], framebufColour[1], framebufColour[2]];\r\n    }, shapesDrawSettings);\r\n\r\n    const fireLookupSettings = {\r\n      output: [_Spectrum__WEBPACK_IMPORTED_MODULE_2__[\"FIRE_SPECTRUM_WIDTH\"]],\r\n      pipeline: false,\r\n      immutable: false,\r\n      constants: {\r\n        FIRE_THRESHOLD: 7,\r\n        MAX_FIRE_ALPHA: 1.0,\r\n        FULL_ON_FIRE: 100,\r\n      },\r\n      returnType: 'Array(4)',\r\n      argumentTypes: {spectrum: 'Array1D(4)'}\r\n    };\r\n    this.fireLookupGen = this.gpu.createKernel(function(spectrum) {\r\n      const idx = this.thread.x;\r\n      const result = [0,0,0,0];\r\n      if (idx >= this.constants.FIRE_THRESHOLD) {\r\n        const currSpectrumVal = spectrum[idx];\r\n        result[0] = currSpectrumVal[0];\r\n        result[1] = currSpectrumVal[1];\r\n        result[2] = currSpectrumVal[2];\r\n        result[3] = this.constants.MAX_FIRE_ALPHA * ((idx > this.constants.FULL_ON_FIRE) ? 1.0 : (idx - this.constants.FIRE_THRESHOLD)/(this.constants.FULL_ON_FIRE - this.constants.FIRE_THRESHOLD));\r\n      }\r\n      return result;\r\n    }, fireLookupSettings);\r\n\r\n    this.fireOverwrite = this.gpu.createKernel(function(fireLookup, temperatureArr, offsetXYZ) {\r\n      const gridSizePlus2 = this.constants.gridSize + 2;\r\n      const index = (this.thread.z + offsetXYZ[2])*gridSizePlus2*gridSizePlus2 + (this.thread.y + offsetXYZ[1])*gridSizePlus2 + (this.thread.x + offsetXYZ[0]);\r\n\r\n      const temperature = temperatureArr[index];\r\n      const temperatureIdx = clampValue(Math.round(temperature*(this.constants.FIRE_SPECTRUM_WIDTH-1)), 0, this.constants.FIRE_SPECTRUM_WIDTH-1);\r\n\r\n      const voxelColour = fireLookup[temperatureIdx];\r\n      return [\r\n        clampValue(voxelColour[3]*voxelColour[0], 0, 1), \r\n        clampValue(voxelColour[3]*voxelColour[1], 0, 1), \r\n        clampValue(voxelColour[3]*voxelColour[2], 0, 1)\r\n      ];\r\n    }, \r\n    {...this.pipelineFuncSettings, \r\n      immutable: immutable,\r\n      argumentTypes: {\r\n        fireLookupTex: 'Array1D(4)', \r\n        temperatureArr: 'Array', \r\n        offsetXYZ: 'Array'\r\n      },\r\n      constants: {...this.pipelineFuncSettings.constants,\r\n        FIRE_SPECTRUM_WIDTH: _Spectrum__WEBPACK_IMPORTED_MODULE_2__[\"FIRE_SPECTRUM_WIDTH\"],\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (GPUKernelManager);\n\n//# sourceURL=webpack:///./src/Server/GPUKernelManager.js?");

/***/ }),

/***/ "./src/Server/VoxelFramebuffer.js":
/*!****************************************!*\
  !*** ./src/Server/VoxelFramebuffer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\n\r\n\r\n\r\nclass VoxelFramebuffer {\r\n  constructor(index) {\r\n    this._index = index;\r\n  }\r\n  get index() { return this._index; }\r\n\r\n  static get VOXEL_FRAMEBUFFER_CPU_TYPE() { return 0; }\r\n  static get VOXEL_FRAMEBUFFER_GPU_TYPE() { return 1; }\r\n\r\n  getType() { console.error(\"getType abstract method call\"); return null; }\r\n\r\n  getBuffer()    { console.error(\"getBuffer abstract method call.\"); return null; }\r\n  getCPUBuffer() { console.error(\"getCPUBuffer abstract method call.\"); return null; }\r\n  getGPUBuffer() { console.error(\"getGPUBuffer abstract method call.\"); return null; }\r\n\r\n  // Implemented in child classes\r\n  setVoxel(pt, colour) { console.error(\"setVoxel abstract method call.\"); } \r\n  addToVoxel(pt, colour) { console.error(\"addToVoxel abstract method call.\"); }\r\n\r\n  clear(colour) { console.error(\"clear abstract method call.\"); }\r\n\r\n  drawFramebuffer(framebuffer, blendMode) { console.error(\"drawFramebuffer abstract method call.\"); }\r\n  drawCombinedFramebuffers(fb1, fb2, options) { console.error(\"drawCombinedFramebuffers abstract method call.\"); }\r\n\r\n  drawPoint(pt, colour, blendMode) { console.error(\"drawPoint abstract method call.\"); }\r\n  drawBox(minPt, maxPt, colour, fill, blendMode) { console.error(\"drawBox abstract method call.\"); }\r\n  drawSphere(center, radius, colour, fill, blendMode) { console.error(\"drawSphere abstract method call.\"); }\r\n  drawSpheres(center, radii, colours, brightness) { console.error(\"drawSpheres abstract method call.\"); }\r\n  drawCubes(center, radii, colours, brightness) { console.error(\"drawCubes abstract method call.\"); }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VoxelFramebuffer);\r\n\r\n\n\n//# sourceURL=webpack:///./src/Server/VoxelFramebuffer.js?");

/***/ }),

/***/ "./src/Server/VoxelFramebufferCPU.js":
/*!*******************************************!*\
  !*** ./src/Server/VoxelFramebufferCPU.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VoxelFramebuffer */ \"./src/Server/VoxelFramebuffer.js\");\n/* harmony import */ var _VoxelModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n\r\n\r\n\r\n\r\nclass VoxelFramebufferCPU extends _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  constructor(index, gridSize, gpuKernelMgr) {\r\n    super(index);\r\n\r\n    this.gridSize = gridSize;\r\n    this.gpuKernelMgr = gpuKernelMgr;\r\n\r\n    // Build the 3D array of voxels for the _buffer itself\r\n    this._buffer = [];\r\n    for (let x = 0; x < gridSize; x++) {\r\n      let currXArr = [];\r\n      this._buffer.push(currXArr);\r\n      for (let y = 0; y < gridSize; y++) {\r\n        let currYArr = [];\r\n        currXArr.push(currYArr);\r\n        for (let z = 0; z < gridSize; z++) {\r\n          currYArr.push([0,0,0]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getType() { return _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VOXEL_FRAMEBUFFER_CPU_TYPE; }\r\n\r\n  getBuffer() { return this._buffer; }\r\n  getCPUBuffer() { return this._buffer; }\r\n  getGPUBuffer() { return this.gpuKernelMgr.copyFramebufferFuncImmutable(this._buffer); } // NOTE: The resulting texture must be deleted by calling delete() on it!\r\n\r\n  _setVoxelNoCheck(pt, colour) {\r\n    const voxelColour = this._buffer[pt[0]][pt[1]][pt[2]];\r\n    voxelColour[0] = colour[0];\r\n    voxelColour[1] = colour[1];\r\n    voxelColour[2] = colour[2];\r\n  }\r\n\r\n  setVoxel(pt, colour) {\r\n    const adjustedX = Math.floor(pt[0]);\r\n    const adjustedY = Math.floor(pt[1]);\r\n    const adjustedZ = Math.floor(pt[2]);\r\n\r\n    if (adjustedX >= 0 && adjustedX < this.gridSize &&\r\n        adjustedY >= 0 && adjustedY < this.gridSize &&\r\n        adjustedZ >= 0 && adjustedZ < this.gridSize) {\r\n      this._setVoxelNoCheck([adjustedX, adjustedY, adjustedZ], colour);\r\n    } \r\n  }\r\n\r\n  _addToVoxelNoCheck(pt, colour) {\r\n    const voxelColour = this._buffer[pt[0]][pt[1]][pt[2]];\r\n    voxelColour[0] = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"clamp\"])(voxelColour[0] + colour[0], 0, 1);\r\n    voxelColour[1] = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"clamp\"])(voxelColour[1] + colour[1], 0, 1);\r\n    voxelColour[2] = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"clamp\"])(voxelColour[2] + colour[2], 0, 1);\r\n  }\r\n\r\n  addToVoxel(pt, colour) {\r\n    const adjustedX = Math.floor(pt[0]);\r\n    const adjustedY = Math.floor(pt[1]);\r\n    const adjustedZ = Math.floor(pt[2]);\r\n\r\n    if (adjustedX >= 0 && adjustedX < this.gridSize &&\r\n        adjustedY >= 0 && adjustedY < this.gridSize &&\r\n        adjustedZ >= 0 && adjustedZ < this.gridSize) {\r\n      this._addToVoxelNoCheck([adjustedX, adjustedY, adjustedZ], colour);\r\n    } \r\n  }\r\n\r\n  clear(colour) {\r\n    for (let x = 0; x < this.gridSize; x++) {\r\n      for (let y = 0; y < this.gridSize; y++) {\r\n        for (let z = 0; z < this.gridSize; z++) {\r\n          const voxelColour = this._buffer[x][y][z];\r\n          voxelColour[0] = colour[0];\r\n          voxelColour[1] = colour[1];\r\n          voxelColour[2] = colour[2];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  drawFramebuffer(framebuffer, blendMode) {\r\n    const bufferToDraw = framebuffer.getCPUBuffer();\r\n    const blendFunc = this._getBlendFuncNoCheck(blendMode);\r\n\r\n    for (let x = 0; x < this.gridSize; x++) {\r\n      for (let y = 0; y < this.gridSize; y++) {\r\n        for (let z = 0; z < this.gridSize; z++) {\r\n          blendFunc([x,y,z], bufferToDraw[x][y][z]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  drawCombinedFramebuffers(fb1, fb2, options) {\r\n    console.error(\"drawCombinedFramebuffers called on CPU Framebuffer.\");\r\n  }\r\n\r\n  drawPoint(pt, colour, blendMode) {\r\n    const blendFunc = this._getBlendFunc(blendMode);\r\n    blendFunc(pt, colour);\r\n  }\r\n  drawPointNoCheck(pt, colour, blendMode) {\r\n    const blendFunc = this._getBlendFuncNoCheck(blendMode);\r\n    blendFunc(pt, colour);\r\n  }\r\n\r\n  drawBox(minPt, maxPt, colour, fill, blendMode) {\r\n    const gridSize = this._buffer.length;\r\n    const boxPts = _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].voxelBoxList(minPt, maxPt, fill, _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].voxelBoundingBox(gridSize, gridSize, gridSize));\r\n    const blendDrawPointFunc = this._getBlendFuncNoCheck(blendMode);\r\n    const colourArr = [colour.r, colour.g, colour.b];\r\n\r\n    boxPts.forEach((pt) => {\r\n      blendDrawPointFunc([pt.x, pt.y, pt.z], colourArr);\r\n    });\r\n  }\r\n\r\n  drawSphere(center, radius, colour, fill, blendMode) {\r\n    const gridSize = this._buffer.length;\r\n    const spherePts = _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].voxelSphereList(center, radius, fill, _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].voxelBoundingBox(gridSize, gridSize, gridSize));\r\n    const blendDrawPointFunc = this._getBlendFuncNoCheck(blendMode);\r\n    const colourArr = [colour.r, colour.g, colour.b];\r\n\r\n    spherePts.forEach((pt) => {\r\n      blendDrawPointFunc([pt.x, pt.y, pt.z], colourArr);\r\n    });\r\n  }\r\n\r\n  _getBlendFunc(blendMode) {\r\n    return (blendMode === _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"BLEND_MODE_ADDITIVE\"] ? this.addToVoxel : this.setVoxel).bind(this);\r\n  }\r\n  _getBlendFuncNoCheck(blendMode) {\r\n    return (blendMode === _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"BLEND_MODE_ADDITIVE\"] ? this._addToVoxelNoCheck : this._setVoxelNoCheck).bind(this);\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VoxelFramebufferCPU);\n\n//# sourceURL=webpack:///./src/Server/VoxelFramebufferCPU.js?");

/***/ }),

/***/ "./src/Server/VoxelFramebufferGPU.js":
/*!*******************************************!*\
  !*** ./src/Server/VoxelFramebufferGPU.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VoxelFramebuffer */ \"./src/Server/VoxelFramebuffer.js\");\n/* harmony import */ var _VoxelModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VoxelModel */ \"./src/Server/VoxelModel.js\");\n\r\n\r\n\r\nclass VoxelFramebufferGPU extends _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  constructor(index, gpuKernelMgr) {\r\n    super(index);\r\n\r\n    this.gpuKernelMgr = gpuKernelMgr;\r\n    this._bufferTexture = this.gpuKernelMgr.clearFunc([0,0,0]);\r\n  }\r\n\r\n  getType() { return _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VOXEL_FRAMEBUFFER_GPU_TYPE; }\r\n\r\n  getBuffer() { return this._bufferTexture; }\r\n  getCPUBuffer() { return this._bufferTexture.toArray(); }\r\n  getGPUBuffer() { return this._bufferTexture; }\r\n\r\n  setVoxel(pt, colour) {\r\n    console.error(\"setVoxel called on GPU Framebuffer.\");\r\n  } \r\n  addToVoxel(pt, colour) {\r\n    console.error(\"addToVoxel called on GPU Framebuffer.\");\r\n  }\r\n\r\n  clear(colour) {\r\n    this._bufferTexture = this.gpuKernelMgr.clearFunc(colour);\r\n  }\r\n\r\n  drawFramebuffer(framebuffer, blendMode) {\r\n    const bufferToDraw = framebuffer.getGPUBuffer();\r\n    switch (blendMode) {\r\n      case _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"BLEND_MODE_ADDITIVE\"]:\r\n        this._bufferTexture = this.gpuKernelMgr.addFramebuffersFunc(this._bufferTexture, bufferToDraw);\r\n        break;\r\n      case _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"BLEND_MODE_OVERWRITE\"]:\r\n        this._bufferTexture = this.gpuKernelMgr.copyFramebufferFunc(bufferToDraw);\r\n        break;\r\n      default:\r\n        console.log(\"Invalid blend mode.\");\r\n        break;\r\n    }\r\n\r\n    if (framebuffer.getType() === _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VOXEL_FRAMEBUFFER_CPU_TYPE) {\r\n      bufferToDraw.delete();\r\n    }\r\n  }\r\n\r\n  drawCombinedFramebuffers(fb1, fb2, options) {\r\n    switch (options.mode) {\r\n      case _VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].FB1_ALPHA_FB2_ONE_MINUS_ALPHA: {\r\n        const fb1GPUBuffer = fb1.getGPUBuffer();\r\n        const fb2GPUBuffer = fb2.getGPUBuffer();\r\n\r\n        this._bufferTexture = this.gpuKernelMgr.combineFramebuffersAlphaOneMinusAlphaFunc(fb1GPUBuffer, fb2GPUBuffer, options.alpha, 1.0-options.alpha);\r\n\r\n        if (fb1.getType() === _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VOXEL_FRAMEBUFFER_CPU_TYPE) {\r\n          fb1GPUBuffer.delete();\r\n        }\r\n        if (fb2.getType() === _VoxelFramebuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VOXEL_FRAMEBUFFER_CPU_TYPE) {\r\n          fb2GPUBuffer.delete();\r\n        }\r\n\r\n        break;\r\n      }\r\n       \r\n      default:\r\n        console.log(\"Invalid framebuffer combination mode.\");\r\n        break;\r\n    }\r\n  }\r\n\r\n  drawPoint(pt, colour, blendMode) { console.error(\"drawPoint called on GPU Framebuffer.\"); }\r\n  drawBox(minPt, maxPt, colour, fill, blendMode) { console.error(\"drawBox called on GPU Framebuffer.\"); }\r\n  drawSphere(center, radius, colour, fill, blendMode) { console.error(\"drawSphere called on GPU Framebuffer.\"); }\r\n\r\n  drawSpheres(center, radii, colours, brightness) {\r\n    const radiiSqr = radii.map(r => r*r);\r\n    const originalBuffer = this._bufferTexture;\r\n    this._bufferTexture = this.gpuKernelMgr.spheresFillOverwrite(originalBuffer, center, radiiSqr, colours, brightness);\r\n  }\r\n  drawCubes(center, radii, colours, brightness) {\r\n    const originalBuffer = this._bufferTexture;\r\n    this._bufferTexture = this.gpuKernelMgr.cubesFillOverwrite(originalBuffer, center, radii, colours, brightness);\r\n  }\r\n\r\n  drawFire(fireLookup, temperatureArr, offsetXYZ) {\r\n    this._bufferTexture = this.gpuKernelMgr.fireOverwrite(fireLookup, temperatureArr, offsetXYZ);\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VoxelFramebufferGPU);\n\n//# sourceURL=webpack:///./src/Server/VoxelFramebufferGPU.js?");

/***/ }),

/***/ "./src/Server/VoxelModel.js":
/*!**********************************!*\
  !*** ./src/Server/VoxelModel.js ***!
  \**********************************/
/*! exports provided: VOXEL_SIZE, HALF_VOXEL_SIZE, BLEND_MODE_OVERWRITE, BLEND_MODE_ADDITIVE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VOXEL_SIZE\", function() { return VOXEL_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HALF_VOXEL_SIZE\", function() { return HALF_VOXEL_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BLEND_MODE_OVERWRITE\", function() { return BLEND_MODE_OVERWRITE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BLEND_MODE_ADDITIVE\", function() { return BLEND_MODE_ADDITIVE; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Animation/VoxelAnimator */ \"./src/Animation/VoxelAnimator.js\");\n/* harmony import */ var _Animation_VoxelColourAnimator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Animation/VoxelColourAnimator */ \"./src/Animation/VoxelColourAnimator.js\");\n/* harmony import */ var _Animation_StarShowerAnimator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Animation/StarShowerAnimator */ \"./src/Animation/StarShowerAnimator.js\");\n/* harmony import */ var _Animation_ShapeWaveAnimator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Animation/ShapeWaveAnimator */ \"./src/Animation/ShapeWaveAnimator.js\");\n/* harmony import */ var _Animation_FireAnimator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Animation/FireAnimator */ \"./src/Animation/FireAnimator.js\");\n/* harmony import */ var _Animation_SceneAnimator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Animation/SceneAnimator */ \"./src/Animation/SceneAnimator.js\");\n/* harmony import */ var _Animation_AudioVisualizerAnimator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Animation/AudioVisualizerAnimator */ \"./src/Animation/AudioVisualizerAnimator.js\");\n/* harmony import */ var _VoxelTracer_VTScene__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../VoxelTracer/VTScene */ \"./src/VoxelTracer/VTScene.js\");\n/* harmony import */ var _VoxelFramebufferCPU__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./VoxelFramebufferCPU */ \"./src/Server/VoxelFramebufferCPU.js\");\n/* harmony import */ var _VoxelFramebufferGPU__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./VoxelFramebufferGPU */ \"./src/Server/VoxelFramebufferGPU.js\");\n/* harmony import */ var _GPUKernelManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./GPUKernelManager */ \"./src/Server/GPUKernelManager.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst VOXEL_SIZE = 1.0;\r\nconst HALF_VOXEL_SIZE = VOXEL_SIZE / 2.0;\r\n\r\nconst BLEND_MODE_OVERWRITE = 0;\r\nconst BLEND_MODE_ADDITIVE  = 1;\r\n\r\nconst DEFAULT_POLLING_FREQUENCY_HZ = 60; // Render Frames per second - if this is too high then we overwhelm our clients\r\nconst DEFAULT_POLLING_INTERVAL_MS  = 1000 / DEFAULT_POLLING_FREQUENCY_HZ;\r\n\r\nclass VoxelModel {\r\n\r\n  // Framebuffer index constants\r\n  static get GPU_FRAMEBUFFER_IDX_0() { return 0; }\r\n  static get GPU_FRAMEBUFFER_IDX_1() { return 1; }\r\n  static get CPU_FRAMEBUFFER_IDX_0() { return 2; }\r\n  static get CPU_FRAMEBUFFER_IDX_1() { return 3; }\r\n\r\n  static getOtherFramebufferIndex(idx) {\r\n    switch (idx) {\r\n      case VoxelModel.GPU_FRAMEBUFFER_IDX_0: return VoxelModel.GPU_FRAMEBUFFER_IDX_1;\r\n      case VoxelModel.GPU_FRAMEBUFFER_IDX_1: return VoxelModel.GPU_FRAMEBUFFER_IDX_0;\r\n      case VoxelModel.CPU_FRAMEBUFFER_IDX_0: return VoxelModel.CPU_FRAMEBUFFER_IDX_1;\r\n      case VoxelModel.CPU_FRAMEBUFFER_IDX_1: return VoxelModel.CPU_FRAMEBUFFER_IDX_0;\r\n      default:\r\n        console.log(\"Invalid framebuffer index.\");\r\n        break;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Framebuffer combination constants\r\n  static get FB1_ALPHA_FB2_ONE_MINUS_ALPHA() { return 0; }\r\n\r\n  constructor(gridSize) {\r\n\r\n    this.gridSize = gridSize;\r\n    this.blendMode = BLEND_MODE_OVERWRITE;\r\n    this.gpuKernelMgr = new _GPUKernelManager__WEBPACK_IMPORTED_MODULE_12__[\"default\"](gridSize);\r\n\r\n    // Note: Indices MUST match up with the constants for *_FRAMEBUFFER_IDX_* !!!!\r\n    this._framebuffers = [\r\n      new _VoxelFramebufferGPU__WEBPACK_IMPORTED_MODULE_11__[\"default\"](0, this.gpuKernelMgr),\r\n      new _VoxelFramebufferGPU__WEBPACK_IMPORTED_MODULE_11__[\"default\"](1, this.gpuKernelMgr),\r\n      new _VoxelFramebufferCPU__WEBPACK_IMPORTED_MODULE_10__[\"default\"](2, gridSize, this.gpuKernelMgr),\r\n      new _VoxelFramebufferCPU__WEBPACK_IMPORTED_MODULE_10__[\"default\"](3, gridSize, this.gpuKernelMgr),\r\n    ];\r\n    this._framebufferIdx = VoxelModel.GPU_FRAMEBUFFER_IDX_0;\r\n\r\n    // Build a voxel tracer scene, which will be shared by all animators that use it\r\n    this.vtScene = new _VoxelTracer_VTScene__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this); //new VTSceneMultithreading(this);\r\n    this._animators = {\r\n      [_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_TYPE_COLOUR]       : new _Animation_VoxelColourAnimator__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this),\r\n      [_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_TYPE_STAR_SHOWER]  : new _Animation_StarShowerAnimator__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this),\r\n      [_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_TYPE_SHAPE_WAVES]  : new _Animation_ShapeWaveAnimator__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this),\r\n      [_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_FIRE]              : new _Animation_FireAnimator__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this),\r\n      [_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_SCENE]             : new _Animation_SceneAnimator__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this, this.vtScene),\r\n      [_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_SOUND_VIZ]         : new _Animation_AudioVisualizerAnimator__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this, this.vtScene),\r\n    };\r\n\r\n    this.currentAnimator = this._animators[_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_TYPE_COLOUR];\r\n\r\n    this.currFrameTime = Date.now();\r\n    this.frameCounter = 0;\r\n\r\n    // Crossfading\r\n    this.totalCrossfadeTime = _Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_CROSSFADE_TIME_SECS\"];\r\n    this.crossfadeCounter = Infinity;\r\n    this.prevAnimator = null;\r\n  }\r\n\r\n  xSize() { return this.gridSize; }\r\n  ySize() { return this.gridSize; }\r\n  zSize() { return this.gridSize; }\r\n  numVoxels() { return this.xSize()*this.ySize()*this.zSize(); }\r\n\r\n  setFramebuffer(idx=0) { this._framebufferIdx = idx; }\r\n  get framebuffer() {\r\n    return this._framebuffers[this._framebufferIdx];\r\n  }\r\n\r\n  async test() {\r\n    /*\r\n    this.setFramebuffer(VoxelModel.CPU_FRAMEBUFFER_IDX_0);\r\n    this.clear();\r\n    for (let x = 0; x < this.xSize(); x++) {\r\n      for (let y = 0; y < this.ySize(); y++) {\r\n        for (let z = 0; z < this.zSize(); z++) {\r\n          this.drawPoint(new THREE.Vector3(x, y, z), new THREE.Color(x, y, z));\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(\"CPU:\");\r\n    this.debugPrintVoxelTexture(true);\r\n\r\n    this.setFramebuffer(VoxelModel.GPU_FRAMEBUFFER_IDX_0);\r\n    this.clear();\r\n    this.drawFramebuffer(VoxelModel.CPU_FRAMEBUFFER_IDX_0);\r\n    console.log(\"GPU:\");\r\n    this.debugPrintVoxelTexture(false);\r\n    */\r\n\r\n    /*\r\n    while (true) {\r\n      this.setFramebuffer(VoxelModel.GPU_FRAMEBUFFER_IDX_0);\r\n      this.clear();\r\n      this.framebuffer.getCPUBuffer();\r\n    }\r\n    */\r\n    /*\r\n    const scene = new VTSceneTest(this);\r\n    const sceneAnim = new SceneAnimator(this, scene);\r\n    await sceneAnim.render(0.001);\r\n    */\r\n  }\r\n\r\n  debugPrintVoxelTexture(isCPU) {\r\n    const arr = this.framebuffer.getCPUBuffer();\r\n    //console.log(arr);\r\n\r\n    const strArr = [];\r\n    for (let x = 0; x < this.xSize(); x++) {\r\n      for (let y = 0; y < this.ySize(); y++) {\r\n        const temp = [];\r\n        for (let z = 0; z < this.zSize(); z++) {\r\n          const currColour = arr[x][y][z];\r\n          temp.push(\"(\"+currColour[0].toFixed(0)+\",\"+currColour[1].toFixed(0)+\",\"+currColour[2].toFixed(0)+\")\")\r\n        }\r\n        strArr.push(temp.join(\", \"));\r\n      }\r\n    }\r\n    console.log(strArr.join(\"\\n\"));\r\n  }\r\n\r\n  setAnimator(type, config) {\r\n    if (!(type in this._animators)) {\r\n      return false;\r\n    }\r\n\r\n    // Check to see if we're changing animators\r\n    const nextAnimator = this._animators[type];\r\n    if (this.currentAnimator !== nextAnimator) {\r\n      this.prevAnimator = this.currentAnimator;\r\n      this.currentAnimator = nextAnimator;\r\n      this.crossfadeCounter = 0;\r\n    }\r\n\r\n    if (config) {\r\n      this.currentAnimator.setConfig(config);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  setCrossfadeTime(t) {\r\n    this.totalCrossfadeTime = Math.max(0, t);\r\n    this._animators[_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_SCENE].setCrossfadeTime(this.totalCrossfadeTime);\r\n    this._animators[_Animation_VoxelAnimator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_ANIM_SOUND_VIZ].setCrossfadeTime(this.totalCrossfadeTime);\r\n  }\r\n\r\n  run(voxelServer) {\r\n    let self = this;\r\n    let lastFrameTime = Date.now();\r\n    let dt = 0;\r\n    let dtSinceLastRender = 0;\r\n    let skipFrameNumber = 1;\r\n    let renderLoopTimerId = -1;\r\n\r\n    const renderLoop = async function() {\r\n      self.currFrameTime = Date.now();\r\n      dt = (self.currFrameTime - lastFrameTime) / 1000;\r\n      dtSinceLastRender += dt;\r\n\r\n      // Simulate the model based on the current animation...\r\n      this.blendMode = BLEND_MODE_OVERWRITE;\r\n\r\n      // Deal with crossfading between animators\r\n      if (self.prevAnimator) {\r\n        // Adjust the animator alphas as a percentage of the crossfade time and continue counting the total time until the crossfade is complete\r\n        const percentFade = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(self.crossfadeCounter / self.totalCrossfadeTime, 0, 1);\r\n        const prevAnimator = self.prevAnimator;\r\n\r\n        if (self.crossfadeCounter < self.totalCrossfadeTime) {\r\n          self.crossfadeCounter += dtSinceLastRender;\r\n        }\r\n        else {\r\n          // no longer crossfading, reset to just showing the current scene\r\n          self.crossfadeCounter = Infinity;\r\n          self.prevAnimator.stop();\r\n          self.prevAnimator = null;\r\n        }\r\n\r\n        // Blend the currentAnimtor with the previous one via framebuffer - we need to do this so that we\r\n        // aren't just overwriting the voxel framebuffer despite the crossfade amounts for each animation\r\n        const prevAnimatorFBIdx = prevAnimator.rendersToCPUOnly() ? VoxelModel.CPU_FRAMEBUFFER_IDX_0 : VoxelModel.GPU_FRAMEBUFFER_IDX_0;\r\n        self.setFramebuffer(prevAnimatorFBIdx);\r\n        self.clear();\r\n        await prevAnimator.render(dtSinceLastRender);\r\n\r\n        const currAnimatorFBIdx = self.currentAnimator.rendersToCPUOnly() ? VoxelModel.CPU_FRAMEBUFFER_IDX_1 : VoxelModel.GPU_FRAMEBUFFER_IDX_1;\r\n        self.setFramebuffer(currAnimatorFBIdx);\r\n        self.clear();\r\n        await self.currentAnimator.render(dtSinceLastRender);\r\n\r\n        self.setFramebuffer(VoxelModel.GPU_FRAMEBUFFER_IDX_0);\r\n        self.drawCombinedFramebuffers(currAnimatorFBIdx, prevAnimatorFBIdx, {mode: VoxelModel.FB1_ALPHA_FB2_ONE_MINUS_ALPHA, alpha: percentFade});\r\n      }\r\n      else {\r\n        // No crossfade, just render the current animation\r\n        const currFBIdx = self.currentAnimator.rendersToCPUOnly() ? VoxelModel.CPU_FRAMEBUFFER_IDX_0 : VoxelModel.GPU_FRAMEBUFFER_IDX_0;\r\n        self.setFramebuffer(currFBIdx);\r\n        self.clear();\r\n        await self.currentAnimator.render(dtSinceLastRender);\r\n      }\r\n\r\n      dtSinceLastRender = 0;\r\n      skipFrameNumber = 1;\r\n\r\n      // Let the server know to broadcast the new voxel data to all clients\r\n      voxelServer.setVoxelData(self.framebuffer.getCPUBuffer(), self.frameCounter);\r\n      self.frameCounter++;\r\n\r\n      lastFrameTime = self.currFrameTime;\r\n\r\n      // Make sure we're keeping up with the set framerate, accounting for the time it took to execute the current frame\r\n      const currTotalFrameTime = Date.now() - self.currFrameTime;\r\n      renderLoopTimerId = setTimeout(renderLoop, Math.max(0, DEFAULT_POLLING_INTERVAL_MS-currTotalFrameTime));\r\n    };\r\n\r\n    renderLoopTimerId = setTimeout(renderLoop, DEFAULT_POLLING_INTERVAL_MS);\r\n  }\r\n \r\n  /**\r\n   * Check whether the given point is in the local space bounds of the voxels.\r\n   * @param {THREE.Vector3} pt \r\n   */\r\n  isInBounds(pt) {\r\n    const adjustedX = Math.floor(pt.x);\r\n    const adjustedY = Math.floor(pt.y);\r\n    const adjustedZ = Math.floor(pt.z);\r\n    return adjustedX >= 0 && adjustedX < this.xSize() && adjustedY >= 0 && adjustedY < this.ySize() && adjustedZ >= 0 && adjustedZ < this.zSize();\r\n  }\r\n\r\n  /**\r\n   * Get the local space Axis-Aligned Bounding Box for all voxels.\r\n   */\r\n  getBoundingBox() {\r\n    return VoxelModel.voxelBoundingBox(this.xSize(), this.ySize(), this.zSize());\r\n  }\r\n  static voxelBoundingBox(xSize, ySize, zSize) {\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](xSize-1, ySize-1, zSize-1));\r\n  }\r\n  \r\n  setVoxel(pt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0))   {\r\n    this.framebuffer.setVoxel([pt.x, pt.y, pt.z], [colour.r, colour.g, colour.b]);\r\n  }\r\n  addToVoxel(pt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0)) {\r\n    this.framebuffer.addToVoxel([pt.x, pt.y, pt.z], [colour.r, colour.g, colour.b]);\r\n  }\r\n\r\n  static voxelIdStr(voxelPt) {\r\n    return voxelPt.x.toFixed(0) + \"_\" + voxelPt.y.toFixed(0) + \"_\" + voxelPt.z.toFixed(0);\r\n  }\r\n  static voxelFlatIdx(voxelPt, gridSize) {\r\n    return voxelPt.x*gridSize*gridSize + voxelPt.y*gridSize + voxelPt.z;\r\n  }\r\n\r\n  static calcVoxelBoundingBox(voxelPt) {\r\n    const adjustedX = Math.floor(voxelPt.x);\r\n    const adjustedY = Math.floor(voxelPt.y);\r\n    const adjustedZ = Math.floor(voxelPt.z);\r\n\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"](\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](adjustedX, adjustedY, adjustedZ), \r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](adjustedX + VOXEL_SIZE, adjustedY + VOXEL_SIZE, adjustedZ + VOXEL_SIZE)\r\n    );\r\n  }\r\n\r\n  static closestVoxelIdxPt(pt) {\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](Math.floor(pt.x), Math.floor(pt.y), Math.floor(pt.z));\r\n  }\r\n\r\n  drawFramebuffer(idx) {\r\n    if (idx === this._framebufferIdx) {\r\n      console.error(\"Attempting to draw a framebuffer into itself, ignoring.\");\r\n      return;\r\n    }\r\n\r\n    this.framebuffer.drawFramebuffer(this._framebuffers[idx], this.blendMode);\r\n  }\r\n\r\n  drawCombinedFramebuffers(fb1Idx, fb2Idx, options) {\r\n    this.framebuffer.drawCombinedFramebuffers(this._framebuffers[fb1Idx], this._framebuffers[fb2Idx], options);\r\n  }\r\n\r\n  clear(colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0)) {\r\n    this.framebuffer.clear([colour.r, colour.g, colour.b]);\r\n  }\r\n\r\n  clearAll(colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0)) {\r\n    const colourArr = [colour.r, colour.g, colour.b];\r\n    for (let i = 0; i < this._framebuffers.length; i++) {\r\n      this._framebuffers[i].clear(colourArr);\r\n    }\r\n  }\r\n\r\n  drawPoint(pt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1)) {\r\n    this.framebuffer.drawPoint([pt.x, pt.y, pt.z], [colour.r, colour.g, colour.b], this.blendMode);\r\n  }\r\n\r\n  drawBox(minPt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), maxPt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1,1,1), colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1), fill=false) {\r\n    this.framebuffer.drawBox(minPt, maxPt, colour, fill, this.blendMode);\r\n  }\r\n\r\n  drawSphere(center=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), radius=1, colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1), fill=false) {\r\n    this.framebuffer.drawSphere(center, radius, colour, fill, this.blendMode);\r\n  }\r\n  drawSpheres(center=[0,0,0], radii, colours, brightness) {\r\n    this.framebuffer.drawSpheres(center, radii, colours, brightness);\r\n  }\r\n  drawCubes(center=[0,0,0], radii, colours, brightness) {\r\n    this.framebuffer.drawCubes(center, radii, colours, brightness);\r\n  }\r\n\r\n  static voxelSphereList(center, radius, fill, voxelBoundingBox) {\r\n    // Create a bounding box for the sphere: \r\n    // Centered at the given center with a half width/height/depth of the given radius\r\n    const sphereBounds = new three__WEBPACK_IMPORTED_MODULE_0__[\"Sphere\"](center, radius);\r\n    const sphereBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"](center.clone().subScalar(radius).floor().max(voxelBoundingBox.min), center.clone().addScalar(radius).ceil().min(voxelBoundingBox.max));\r\n\r\n    // Now we go through all the voxels in the bounding box and build a point list\r\n    const voxelPts = [];\r\n    for (let x = sphereBoundingBox.min.x; x <= sphereBoundingBox.max.x; x++) {\r\n      for (let y = sphereBoundingBox.min.y; y <= sphereBoundingBox.max.y; y++) {\r\n        for (let z = sphereBoundingBox.min.z; z <= sphereBoundingBox.max.z; z++) {\r\n\r\n          // Check whether the current voxel is inside the voxel grid and inside the radius of the sphere\r\n          const currPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z);\r\n          const distToCurrPt = sphereBounds.distanceToPoint(currPt);\r\n          if (fill) {\r\n            if (distToCurrPt < _MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_ERR_UNITS\"]) {\r\n              voxelPts.push(currPt);\r\n            }\r\n          }\r\n          else {\r\n            if (Math.abs(distToCurrPt) < _MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_ERR_UNITS\"]) {\r\n              voxelPts.push(currPt);\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n    }\r\n    return voxelPts;\r\n  }\r\n\r\n  static voxelBoxList(minPt, maxPt, fill, voxelBoundingBox) {\r\n    \r\n    const voxelPts = [];\r\n    const mappedMinPt = minPt.clone().floor();\r\n    mappedMinPt.max(voxelBoundingBox.min);\r\n    const mappedMaxPt = maxPt.clone().ceil();\r\n    mappedMaxPt.min(voxelBoundingBox.max);\r\n\r\n    if (fill) {\r\n      for (let x = mappedMinPt.x; x <= mappedMaxPt.x; x++) {\r\n        for (let y = mappedMinPt.y; y <= mappedMaxPt.y; y++) {\r\n          for (let z = mappedMinPt.z; z <= mappedMaxPt.z; z++) {\r\n            voxelPts.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      // Not filling the box... just go around the outside of it\r\n      let incX = Math.floor(mappedMaxPt.x-mappedMinPt.x);\r\n      if (incX <= 0) {\r\n        incX = mappedMaxPt.x-mappedMinPt.x;\r\n      }\r\n\r\n      for (let x = mappedMinPt.x; x <= mappedMaxPt.x; x += incX) {\r\n        for (let y = mappedMinPt.y; y <= mappedMaxPt.y; y++) {\r\n          for (let z = mappedMinPt.z; z <= mappedMaxPt.z; z++) {\r\n            voxelPts.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z));\r\n          }\r\n        }\r\n      }\r\n\r\n      let incY = Math.floor(mappedMaxPt.y-mappedMinPt.y);\r\n      if (incY <= 0) {\r\n        incY = mappedMaxPt.y-mappedMinPt.y;\r\n      }\r\n\r\n      for (let y = mappedMinPt.y; y <= mappedMaxPt.y; y += incY) {\r\n        for (let x = mappedMinPt.x+1; x < mappedMaxPt.x; x++) {\r\n          for (let z = mappedMinPt.z; z <= mappedMaxPt.z; z++) {\r\n            voxelPts.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z));\r\n          }\r\n        }\r\n      }\r\n\r\n      let incZ = Math.floor(mappedMaxPt.z-mappedMinPt.z);\r\n      if (incZ <= 0) {\r\n        incZ = mappedMaxPt.z-mappedMinPt.z;\r\n      }\r\n\r\n      for (let z = mappedMinPt.z; z <= mappedMaxPt.z; z += incZ) {\r\n        for (let x = mappedMinPt.x+1; x < mappedMaxPt.x; x++) {\r\n          for (let y = mappedMinPt.y+1; y < mappedMaxPt.y; y++) {\r\n            voxelPts.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return voxelPts;\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VoxelModel);\n\n//# sourceURL=webpack:///./src/Server/VoxelModel.js?");

/***/ }),

/***/ "./src/Spectrum.js":
/*!*************************!*\
  !*** ./src/Spectrum.js ***!
  \*************************/
/*! exports provided: COLOUR_INTERPOLATION_RGB, COLOUR_INTERPOLATION_HSL, COLOUR_INTERPOLATION_LAB, COLOUR_INTERPOLATION_LCH, COLOUR_INTERPOLATION_LRGB, COLOUR_INTERPOLATION_TYPES, FIRE_SPECTRUM_WIDTH, NTSCsystem, EBUsystem, SMPTEsystem, HDTVsystem, CIEsystem, Rec709system, ColourSystems, generateSpectrum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_INTERPOLATION_RGB\", function() { return COLOUR_INTERPOLATION_RGB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_INTERPOLATION_HSL\", function() { return COLOUR_INTERPOLATION_HSL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_INTERPOLATION_LAB\", function() { return COLOUR_INTERPOLATION_LAB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_INTERPOLATION_LCH\", function() { return COLOUR_INTERPOLATION_LCH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_INTERPOLATION_LRGB\", function() { return COLOUR_INTERPOLATION_LRGB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_INTERPOLATION_TYPES\", function() { return COLOUR_INTERPOLATION_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FIRE_SPECTRUM_WIDTH\", function() { return FIRE_SPECTRUM_WIDTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NTSCsystem\", function() { return NTSCsystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EBUsystem\", function() { return EBUsystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SMPTEsystem\", function() { return SMPTEsystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HDTVsystem\", function() { return HDTVsystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CIEsystem\", function() { return CIEsystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rec709system\", function() { return Rec709system; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColourSystems\", function() { return ColourSystems; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateSpectrum\", function() { return generateSpectrum; });\n\r\nconst COLOUR_INTERPOLATION_RGB  = 'rgb';\r\nconst COLOUR_INTERPOLATION_HSL  = 'hsl';\r\nconst COLOUR_INTERPOLATION_LAB  = 'lab';\r\nconst COLOUR_INTERPOLATION_LCH  = 'lch';\r\nconst COLOUR_INTERPOLATION_LRGB = 'lrgb';\r\nconst COLOUR_INTERPOLATION_TYPES = [\r\n  COLOUR_INTERPOLATION_RGB,\r\n  COLOUR_INTERPOLATION_HSL,\r\n  COLOUR_INTERPOLATION_LAB,\r\n  COLOUR_INTERPOLATION_LCH,\r\n  COLOUR_INTERPOLATION_LRGB,\r\n];\r\n\r\nconst FIRE_SPECTRUM_WIDTH = 256;\r\n\r\n\r\nconst cie_colour_match = [\r\n  [0.0014,0.0000,0.0065], [0.0022,0.0001,0.0105], [0.0042,0.0001,0.0201],\r\n  [0.0076,0.0002,0.0362], [0.0143,0.0004,0.0679], [0.0232,0.0006,0.1102],\r\n  [0.0435,0.0012,0.2074], [0.0776,0.0022,0.3713], [0.1344,0.0040,0.6456],\r\n  [0.2148,0.0073,1.0391], [0.2839,0.0116,1.3856], [0.3285,0.0168,1.6230],\r\n  [0.3483,0.0230,1.7471], [0.3481,0.0298,1.7826], [0.3362,0.0380,1.7721],\r\n  [0.3187,0.0480,1.7441], [0.2908,0.0600,1.6692], [0.2511,0.0739,1.5281],\r\n  [0.1954,0.0910,1.2876], [0.1421,0.1126,1.0419], [0.0956,0.1390,0.8130],\r\n  [0.0580,0.1693,0.6162], [0.0320,0.2080,0.4652], [0.0147,0.2586,0.3533],\r\n  [0.0049,0.3230,0.2720], [0.0024,0.4073,0.2123], [0.0093,0.5030,0.1582],\r\n  [0.0291,0.6082,0.1117], [0.0633,0.7100,0.0782], [0.1096,0.7932,0.0573],\r\n  [0.1655,0.8620,0.0422], [0.2257,0.9149,0.0298], [0.2904,0.9540,0.0203],\r\n  [0.3597,0.9803,0.0134], [0.4334,0.9950,0.0087], [0.5121,1.0000,0.0057],\r\n  [0.5945,0.9950,0.0039], [0.6784,0.9786,0.0027], [0.7621,0.9520,0.0021],\r\n  [0.8425,0.9154,0.0018], [0.9163,0.8700,0.0017], [0.9786,0.8163,0.0014],\r\n  [1.0263,0.7570,0.0011], [1.0567,0.6949,0.0010], [1.0622,0.6310,0.0008],\r\n  [1.0456,0.5668,0.0006], [1.0026,0.5030,0.0003], [0.9384,0.4412,0.0002],\r\n  [0.8544,0.3810,0.0002], [0.7514,0.3210,0.0001], [0.6424,0.2650,0.0000],\r\n  [0.5419,0.2170,0.0000], [0.4479,0.1750,0.0000], [0.3608,0.1382,0.0000],\r\n  [0.2835,0.1070,0.0000], [0.2187,0.0816,0.0000], [0.1649,0.0610,0.0000],\r\n  [0.1212,0.0446,0.0000], [0.0874,0.0320,0.0000], [0.0636,0.0232,0.0000],\r\n  [0.0468,0.0170,0.0000], [0.0329,0.0119,0.0000], [0.0227,0.0082,0.0000],\r\n  [0.0158,0.0057,0.0000], [0.0114,0.0041,0.0000], [0.0081,0.0029,0.0000],\r\n  [0.0058,0.0021,0.0000], [0.0041,0.0015,0.0000], [0.0029,0.0010,0.0000],\r\n  [0.0020,0.0007,0.0000], [0.0014,0.0005,0.0000], [0.0010,0.0004,0.0000],\r\n  [0.0007,0.0002,0.0000], [0.0005,0.0002,0.0000], [0.0003,0.0001,0.0000],\r\n  [0.0002,0.0001,0.0000], [0.0002,0.0001,0.0000], [0.0001,0.0000,0.0000],\r\n  [0.0001,0.0000,0.0000], [0.0001,0.0000,0.0000], [0.0000,0.0000,0.0000]\r\n];\r\n\r\nconst IlluminantC   = [0.3101, 0.3162]; /* For NTSC television */   \t    \t\r\nconst IlluminantD65 = [0.3127, 0.3291];\t/* For EBU and SMPTE */\r\nconst IlluminantE \t= [0.33333333, 0.33333333];  /* CIE equal-energy illuminant */\r\n\r\nconst GAMMA_REC709 = 0;\r\n\r\nconst NTSCsystem   = { name: \"NTSC\",            xRed: 0.67,   yRed: 0.33,   xGreen: 0.21,   yGreen: 0.71,   xBlue: 0.14,   yBlue: 0.08,   xWhite: IlluminantC[0],   yWhite: IlluminantC[1],   gamma: GAMMA_REC709 };\r\nconst EBUsystem    = { name: \"EBU (PAL/SECAM)\", xRed: 0.64,   yRed: 0.33,   xGreen: 0.29,   yGreen: 0.60,   xBlue: 0.15,   yBlue: 0.06,   xWhite: IlluminantD65[0], yWhite: IlluminantD65[1], gamma: GAMMA_REC709 };\r\nconst SMPTEsystem  = { name: \"SMPTE\",           xRed: 0.630,  yRed: 0.340,  xGreen: 0.310,  yGreen: 0.595,  xBlue: 0.155,  yBlue: 0.070,  xWhite: IlluminantD65[0], yWhite: IlluminantD65[1], gamma: GAMMA_REC709 };\r\nconst HDTVsystem   = { name: \"HDTV\",            xRed: 0.670,  yRed: 0.330,  xGreen: 0.210,  yGreen: 0.710,  xBlue: 0.150,  yBlue: 0.060,  xWhite: IlluminantD65[0], yWhite: IlluminantD65[1], gamma: GAMMA_REC709 };\r\nconst CIEsystem    = { name: \"CIE\",             xRed: 0.7355, yRed: 0.2645, xGreen: 0.2658, yGreen: 0.7243, xBlue: 0.1669, yBlue: 0.0085, xWhite: IlluminantE[0],   yWhite: IlluminantE[1],   gamma: GAMMA_REC709 };\r\nconst Rec709system = { name: \"CIE REC 709\",     xRed: 0.64,   yRed: 0.33,   xGreen: 0.30,   yGreen: 0.60,   xBlue: 0.15,   yBlue: 0.06,   xWhite: IlluminantD65[0], yWhite: IlluminantD65[1], gamma: GAMMA_REC709 };\r\n\r\nconst ColourSystems = {\r\n  'NTSCsystem'  : NTSCsystem,\r\n  'EBUsystem'   : EBUsystem,\r\n  'SMPTEsystem' : SMPTEsystem,\r\n  'HDTVsystem'  : HDTVsystem,\r\n  'CIEsystem'   : CIEsystem,\r\n  'Rec709system': Rec709system\r\n};\r\n\r\nconst bb_spectrum = (wavelength, blackbodyTemp) => {\r\n  let wlm = wavelength * 1e-9;\r\n  return (3.74183e-16 * Math.pow(wlm, -5)) / (Math.exp(1.4388e-2 / (wlm * blackbodyTemp)) - 1.0);\r\n}\r\n\r\nconst spectrumToXyz = (specFunc, blackbodyTemp) => {\r\n  let X = 0; let Y = 0; let Z = 0;\r\n  for (let i = 0, lambda = 380; lambda < 780.1; i++, lambda += 5) {\r\n    let Me = specFunc(lambda, blackbodyTemp);\r\n    X += Me * cie_colour_match[i][0];\r\n    Y += Me * cie_colour_match[i][1];\r\n    Z += Me * cie_colour_match[i][2];\r\n  }\r\n\r\n  const XYZ = X+Y+Z;\r\n  return {\r\n    x: X / XYZ,\r\n    y: Y / XYZ,\r\n    z: Z / XYZ\r\n  };\r\n}\r\n\r\nconst xyzToLms = (x, y, z) => {\r\n  return {\r\n    l: 0.3897*x + 0.6890*y - 0.0787*z,\r\n    m: -0.2298*x + 1.1834*y + 0.0464*z,\r\n    s: z\r\n  };\r\n}\r\nconst lmsToXyz = (l, m, s) => {\r\n  return {\r\n    x: 1.9102*l - 1.1121*m + 0.2019*s,\r\n    y: 0.3709*l + 0.6290*m + 0.0000*s,\r\n    z: s\r\n  };\r\n}\r\nconst xyzToRgb = (cs, xc, yc, zc) => {\r\n  let xr, yr, zr, xg, yg, zg, xb, yb, zb;\r\n  let xw, yw, zw;\r\n  let rx, ry, rz, gx, gy, gz, bx, by, bz;\r\n  let rw, gw, bw;\r\n\r\n  xr = cs.xRed;    yr = cs.yRed;    zr = 1 - (xr + yr);\r\n  xg = cs.xGreen;  yg = cs.yGreen;  zg = 1 - (xg + yg);\r\n  xb = cs.xBlue;   yb = cs.yBlue;   zb = 1 - (xb + yb);\r\n\r\n  xw = cs.xWhite;  yw = cs.yWhite;  zw = 1 - (xw + yw);\r\n\r\n  /* xyz . rgb matrix, before scaling to white. */\r\n  \r\n  rx = (yg * zb) - (yb * zg);  ry = (xb * zg) - (xg * zb);  rz = (xg * yb) - (xb * yg);\r\n  gx = (yb * zr) - (yr * zb);  gy = (xr * zb) - (xb * zr);  gz = (xb * yr) - (xr * yb);\r\n  bx = (yr * zg) - (yg * zr);  by = (xg * zr) - (xr * zg);  bz = (xr * yg) - (xg * yr);\r\n\r\n  /* White scaling factors.\r\n     Dividing by yw scales the white luminance to unity, as conventional. */\r\n     \r\n  rw = ((rx * xw) + (ry * yw) + (rz * zw)) / yw;\r\n  gw = ((gx * xw) + (gy * yw) + (gz * zw)) / yw;\r\n  bw = ((bx * xw) + (by * yw) + (bz * zw)) / yw;\r\n\r\n  /* xyz => rgb matrix, correctly scaled to white. */\r\n  \r\n  rx = rx / rw;  ry = ry / rw;  rz = rz / rw;\r\n  gx = gx / gw;  gy = gy / gw;  gz = gz / gw;\r\n  bx = bx / bw;  by = by / bw;  bz = bz / bw;\r\n\r\n  /* rgb of the desired point */\r\n  return {\r\n    r: (rx * xc) + (ry * yc) + (rz * zc),\r\n    g: (gx * xc) + (gy * yc) + (gz * zc),\r\n    b: (bx * xc) + (by * yc) + (bz * zc)\r\n  };\r\n}\r\n\r\nconst constrainRgb = (r, g, b) => {\r\n  /* Amount of white needed is w = - min(0, *r, *g, *b) */\r\n  let w = (0 < r) ? 0 : r;\r\n  w = (w < g) ? w : g;\r\n  w = (w < b) ? w : b;\r\n  w = -w;\r\n\r\n  /* Add just enough white to make r, g, b all positive. */\r\n  if (w > 0) {\r\n    return { r: r+w, g: g+w, b: b+w }; /* Colour modified to fit RGB gamut */\r\n  }\r\n  return { r: r, g: g, b: b };\r\n}\r\nconst normalizeRgb = (r, g, b) => {\r\n  let greatest = Math.max(r, Math.max(g, b));\r\n  let rgb = {r: r, g: g, b: b};\r\n\r\n  if (greatest > 0) {\r\n    rgb.r /= greatest;\r\n    rgb.g /= greatest;\r\n    rgb.b /= greatest;\r\n  }\r\n\r\n  return rgb;\r\n}\r\n\r\n\r\nconst generateSpectrum = (t1, t2, N, colourSystem=CIEsystem) => {\r\n  let j = 0; let dj = 1;\r\n\r\n  if (t1 < t2) {\r\n    let t = t1;\r\n    t1 = t2;\r\n    t2 = t;\r\n    j = N-1; dj = -1;\r\n  }\r\n\r\n  let Lw = 0, Mw = 0, Sw = 0;\r\n  let result = new Array(N);\r\n  for (let i = 0; i < N; i++) {\r\n    let blackbodyTemp = t1 + (t2-t1)/N*i;\r\n    let xyz = spectrumToXyz(bb_spectrum, blackbodyTemp);\r\n    let lms = xyzToLms(xyz.x, xyz.y, xyz.z);\r\n    if (i === 0) {\r\n      Lw = 1/lms.l; Mw = 1/lms.m; Sw = 1/lms.s;\r\n    }\r\n    lms.l *= Lw; lms.m *= Mw; lms.s *= Sw;\r\n    xyz = lmsToXyz(lms.l, lms.m, lms.s);\r\n\r\n    // Convert to RGB\r\n    let rgb = xyzToRgb(colourSystem, xyz.x, xyz.y, xyz.z);\r\n    rgb = constrainRgb(rgb.r, rgb.g, rgb.b);\r\n    rgb = normalizeRgb(rgb.r, rgb.g, rgb.b);\r\n    \r\n    result[j] = [rgb.r, rgb.g, rgb.b, (rgb.b>0.1)? rgb.b : 0];\r\n    \r\n\t\tj += dj;\r\n  }\r\n\r\n  return result;\r\n} \n\n//# sourceURL=webpack:///./src/Spectrum.js?");

/***/ }),

/***/ "./src/VoxelTracer/RenderProc/VTRPScene.js":
/*!*************************************************!*\
  !*** ./src/VoxelTracer/RenderProc/VTRPScene.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n/* harmony import */ var _VTMesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VTMesh */ \"./src/VoxelTracer/VTMesh.js\");\n/* harmony import */ var _VTPointLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VTPointLight */ \"./src/VoxelTracer/VTPointLight.js\");\n/* harmony import */ var _VTFog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../VTFog */ \"./src/VoxelTracer/VTFog.js\");\n/* harmony import */ var _VTVoxel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VTVoxel */ \"./src/VoxelTracer/VTVoxel.js\");\n/* harmony import */ var _VTRenderProc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VTRenderProc */ \"./src/VoxelTracer/RenderProc/VTRenderProc.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass VTRPScene {\r\n\r\n  constructor() {\r\n    this.gridSize = 0;\r\n    this.clear();\r\n  }\r\n\r\n  dispose() {\r\n    Object.values(this.renderables).forEach(renderable => {\r\n      renderable.dispose();\r\n    });\r\n    this.clear();\r\n  }\r\n\r\n  clear() {\r\n    // All renderables and lights are stored by their IDs\r\n    this.renderables = {};\r\n    this.lights = {};\r\n    this.shadowCasters = {};\r\n    this.ambientLight = null;\r\n  }\r\n\r\n  render(renderableToVoxelMapping) {\r\n    const result = [];\r\n    const currVoxelPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n    Object.entries(renderableToVoxelMapping).forEach(entry => {\r\n      const [id, voxelPts] = entry;\r\n      const renderable = this._getRenderable(id);\r\n      for (let i = 0; i < voxelPts.length; i++) {\r\n        const {x,y,z} = voxelPts[i];\r\n        currVoxelPt.set(x, y, z);\r\n        const calcColour = renderable.calculateVoxelColour(currVoxelPt, this);\r\n        if (calcColour.r > 0 || calcColour.g > 0 || calcColour.b > 0) {\r\n          result.push({\r\n            pt: currVoxelPt.clone(),\r\n            colour: calcColour\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    process.send({type: _VTRenderProc__WEBPACK_IMPORTED_MODULE_8__[\"default\"].FROM_PROC_RENDERED, data: result});\r\n  }\r\n\r\n  _getRenderable(id) {\r\n    let result = this.renderables[id];\r\n    if (!result) { result = this.lights[id]; }\r\n    return result;\r\n  }\r\n\r\n  update(sceneData) {\r\n    const {removedIds, reinit, ambientLight, renderables, lights} = sceneData;\r\n\r\n    if (reinit) {\r\n      this.dispose();\r\n    }\r\n    else if (removedIds) {\r\n      for (let i = 0; i < removedIds.length; i++) {\r\n        const removedId = removedIds[i];\r\n        delete this.renderables[removedId];\r\n        delete this.lights[removedId];\r\n        delete this.shadowCasters[removedId];\r\n        if (this.ambientLight.id === removedId) {\r\n          this.ambientLight = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ambientLight) {\r\n      this.ambientLight = _VTAmbientLight__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build(ambientLight);\r\n    }\r\n\r\n    const updatedMap = {};\r\n    if (renderables) {\r\n      for (let i = 0; i < renderables.length; i++) {\r\n        const renderableData = renderables[i];\r\n        this._updateRenderable(renderableData, updatedMap);\r\n      }\r\n    }\r\n    if (lights) {\r\n      for (let i = 0; i < lights.length; i++) {\r\n        const lightData = lights[i];\r\n        this._updateLight(lightData, updatedMap);\r\n      }\r\n    }\r\n\r\n    Object.entries(updatedMap).forEach(entry => {\r\n      const [id, obj] = entry;\r\n\r\n      if (id in this.renderables) {\r\n        this.renderables[id].dispose();\r\n      }\r\n      else if (id in this.lights) {\r\n        this.lights[id].dispose();\r\n      }\r\n\r\n      switch (obj.type) {\r\n        case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].POINT_LIGHT_TYPE:\r\n          this.renderables[id] = obj;\r\n          this.lights[id] = obj;\r\n          break;\r\n        default:\r\n          this.renderables[id] = obj;\r\n          if (obj.isShadowCaster()) {\r\n            this.shadowCasters[id] = obj;\r\n          }\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  _updateRenderable(renderableData, updatedMap) {\r\n    const {id, type} = renderableData;\r\n    if (id in updatedMap) {\r\n      return;\r\n    }\r\n\r\n    let buildFunc = null;\r\n    switch (type) {\r\n      case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].MESH_TYPE:\r\n        buildFunc = _VTMesh__WEBPACK_IMPORTED_MODULE_4__[\"default\"].build;\r\n        break;\r\n      case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].POINT_LIGHT_TYPE:\r\n        buildFunc = _VTPointLight__WEBPACK_IMPORTED_MODULE_5__[\"default\"].build;\r\n        break;\r\n      case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].VOXEL_TYPE:\r\n        buildFunc = _VTVoxel__WEBPACK_IMPORTED_MODULE_7__[\"default\"].build;\r\n        break;\r\n      case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].FOG_TYPE:\r\n        buildFunc = _VTFog__WEBPACK_IMPORTED_MODULE_6__[\"default\"].build;\r\n        break;\r\n\r\n      default:\r\n        console.error(`Unknown VTRenderable object type found: ${type}`);\r\n        return;\r\n    }\r\n\r\n    updatedMap[id] = buildFunc(renderableData);\r\n  }\r\n\r\n  _updateLight(lightData, updatedMap) {\r\n    const {id, type} = lightData;\r\n    if (id in updatedMap) {\r\n      return;\r\n    }\r\n\r\n    let buildFunc = null;\r\n    switch (type) {\r\n      case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].POINT_LIGHT_TYPE:\r\n        buildFunc = _VTPointLight__WEBPACK_IMPORTED_MODULE_5__[\"default\"].build;\r\n        break;\r\n\r\n      case _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].AMBIENT_LIGHT_TYPE:\r\n        this.ambientLight = _VTAmbientLight__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build(lightData);\r\n        return;\r\n\r\n      default:\r\n        console.error(`Unknown VTRenderable light type found: ${type}`);\r\n        return;\r\n    }\r\n    updatedMap[id] = buildFunc(lightData);\r\n  }\r\n\r\n  calculateVoxelLighting(point, material, receivesShadow) {\r\n    // We treat voxels as perfect inifintesmial spheres centered at a given voxel position\r\n    // they can be shadowed and have materials like meshes\r\n    const finalColour = material.emission(null);\r\n    \r\n    const lights = Object.values(this.lights);\r\n    if (lights.length > 0) {\r\n      const nVoxelToLightVec = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n      const raycaster = new three__WEBPACK_IMPORTED_MODULE_0__[\"Raycaster\"]();\r\n\r\n      for (let j = 0; j < lights.length; j++) {\r\n        const light = lights[j];\r\n\r\n        nVoxelToLightVec.set(light.position.x, light.position.y, light.position.z);\r\n        nVoxelToLightVec.sub(point);\r\n        const distanceToLight = Math.max(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_EPSILON\"], nVoxelToLightVec.length());\r\n        nVoxelToLightVec.divideScalar(distanceToLight);\r\n\r\n        let lightMultiplier = 1.0;\r\n        if (receivesShadow) {\r\n\r\n          // Check to see if the voxel is in shadow\r\n          // NOTE: We currently only use point lights so there's only umbra shadow (no soft shadows/sampling)\r\n          raycaster.set(point, nVoxelToLightVec); \r\n          raycaster.near = _MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_EPSILON\"];\r\n          raycaster.far  = distanceToLight;\r\n\r\n          for (let k = 0; k < this.shadowCasters.length; k++) {\r\n            const shadowCaster = this.shadowCasters[k];\r\n            const shadowCasterResult = shadowCaster.calculateShadow(raycaster);\r\n            if (shadowCasterResult.inShadow) {\r\n              lightMultiplier -= shadowCasterResult.lightReduction;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (lightMultiplier > 0) {\r\n          // The voxel is not in total shadow, do the lighting - since it's a \"infitesimal sphere\" the normal is always\r\n          // in the direction of the light, so it's always ambiently lit (unless it's in shadow)\r\n          const lightEmission = light.emission(distanceToLight).multiplyScalar(lightMultiplier);\r\n          const materialLightingColour = material.brdfAmbient(null, lightEmission);\r\n          finalColour.add(materialLightingColour);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.ambientLight) {\r\n      finalColour.add(material.basicBrdfAmbient(null, this.ambientLight.emission()));\r\n    }\r\n\r\n    finalColour.setRGB(Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.r, 0, 1), Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.g, 0, 1), Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.b, 0, 1));\r\n\r\n    return finalColour;\r\n  }\r\n\r\n  calculateFogLighting(point) {\r\n    const finalColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n    const nFogToLightVec = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n\r\n    const lights = Object.values(this.lights);\r\n    if (lights.length > 0) {\r\n      for (let j = 0; j < lights.length; j++) {\r\n        const light = lights[j];\r\n\r\n        nFogToLightVec.set(light.position.x, light.position.y, light.position.z);\r\n        nFogToLightVec.sub(point);\r\n        const distanceToLight = Math.max(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_EPSILON\"], nFogToLightVec.length());\r\n        const lightEmission = light.emission(distanceToLight);\r\n        finalColour.add(lightEmission);\r\n      }\r\n      finalColour.setRGB(Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.r, 0, 1), Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.g, 0, 1), Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.b, 0, 1));\r\n    }\r\n\r\n    return finalColour;\r\n  }\r\n\r\n  calculateLightingSamples(samples, material) {\r\n    const finalColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n    const sampleLightContrib = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n\r\n    // Go through each light in the scene and raytrace to them...\r\n    const nObjToLightVec = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    const raycaster = new three__WEBPACK_IMPORTED_MODULE_0__[\"Raycaster\"]();\r\n\r\n    const factorPerSample = 1.0 / samples.length;\r\n    const lights = Object.values(this.lights);\r\n    const shadowCasters = Object.values(this.shadowCasters);\r\n\r\n    for (let i = 0; i < samples.length; i++) {\r\n      const {point, normal, uv, falloff} = samples[i];\r\n\r\n      sampleLightContrib.copy(material.emission(uv));\r\n\r\n      for (let j = 0; j < lights.length; j++) {\r\n        const light = lights[j];\r\n\r\n        nObjToLightVec.set(light.position.x, light.position.y, light.position.z);\r\n        nObjToLightVec.sub(point);\r\n        const distanceToLight = Math.max(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_EPSILON\"], nObjToLightVec.length());\r\n        nObjToLightVec.divideScalar(distanceToLight);\r\n\r\n        // Early out - is the light vector in the same hemisphere as the normal?\r\n        if (nObjToLightVec.dot(normal) <= 0) {\r\n          continue;\r\n        }\r\n\r\n        // Check to see if the surface is in shadow\r\n        // NOTE: We currently only use point lights so there's only umbra shadow (no soft shadows/sampling)\r\n        raycaster.set(point, nObjToLightVec); \r\n        raycaster.near = _MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_EPSILON\"];\r\n        raycaster.far  = distanceToLight;\r\n\r\n        let lightMultiplier = 1.0;\r\n        \r\n        for (let k = 0; k < shadowCasters.length; k++) {\r\n          const shadowCaster = shadowCasters[k];\r\n          const shadowCasterResult = shadowCaster.calculateShadow(raycaster);\r\n          if (shadowCasterResult.inShadow) {\r\n            lightMultiplier -= shadowCasterResult.lightReduction;\r\n          }\r\n        }\r\n\r\n        if (lightMultiplier > 0) {\r\n          // The voxel is not in total shadow, do the lighting\r\n          const lightEmission = light.emission(distanceToLight).multiplyScalar(lightMultiplier*falloff);\r\n          const materialLightingColour = material.brdf(nObjToLightVec, normal, uv, lightEmission);\r\n          sampleLightContrib.add(materialLightingColour.multiplyScalar(falloff));\r\n        }\r\n      }\r\n      sampleLightContrib.multiplyScalar(factorPerSample);\r\n      finalColour.add(sampleLightContrib);\r\n    }\r\n\r\n    if (this.ambientLight) {\r\n      sampleLightContrib.set(0,0,0);\r\n      for (let i = 0; i < samples.length; i++) {\r\n        const {uv, falloff} = samples[i];\r\n        sampleLightContrib.add(material.basicBrdfAmbient(uv, this.ambientLight.emission()).multiplyScalar(falloff));\r\n      }\r\n      sampleLightContrib.multiplyScalar(factorPerSample);\r\n      finalColour.add(sampleLightContrib);\r\n    }\r\n\r\n    finalColour.setRGB(Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.r, 0, 1), Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.g, 0, 1), Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(finalColour.b, 0, 1));\r\n    return finalColour;\r\n  }\r\n\r\n  \r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTRPScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/RenderProc/VTRPScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/RenderProc/VTRenderProc.js":
/*!****************************************************!*\
  !*** ./src/VoxelTracer/RenderProc/VTRenderProc.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTRPScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTRPScene */ \"./src/VoxelTracer/RenderProc/VTRPScene.js\");\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n\r\n\r\n\r\n\r\nclass VTRenderProc {\r\n  static get TO_PROC_INIT() { return 'i'; }\r\n  static get TO_PROC_UPDATE_SCENE() { return 'u'; }\r\n  static get TO_PROC_UPDATE_VOXEL_INFO() { return 'm'; }\r\n  static get TO_PROC_RENDER() { return 'r'; }\r\n  \r\n  static get FROM_PROC_RENDERED() { return 'f'; }\r\n\r\n  constructor() {\r\n    this.rpScene = new _VTRPScene__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    this.renderableToVoxelMapping = {};\r\n    this.voxelIndexRange = [0,0];\r\n  }\r\n\r\n  run() {\r\n    process.on('message', message => {\r\n      const {type, data} = message;\r\n\r\n      switch (type) {\r\n        case VTRenderProc.TO_PROC_INIT: {\r\n          const {gridSize, voxelIndexRange} = data;\r\n          this.rpScene.gridSize = parseInt(gridSize);\r\n          this.voxelIndexRange = voxelIndexRange;\r\n          break;\r\n        }\r\n\r\n        case VTRenderProc.TO_PROC_UPDATE_SCENE: {\r\n          const {removedIds} = data;\r\n          // The data is an object with all of the scene objects that need to be updated inside of it\r\n          this.rpScene.update(data);\r\n          // Remove mappings if necessary\r\n          if (removedIds) {\r\n            for (let i = 0; i < removedIds.length; i++) {\r\n              const removedId = removedIds[i];\r\n              delete this.renderableToVoxelMapping[removedId];\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case VTRenderProc.TO_PROC_UPDATE_VOXEL_INFO: {\r\n          if (data.reinit) {\r\n            this.renderableToVoxelMapping = data.mapping;\r\n          }\r\n          else {\r\n            const {mapping, updatedRenderableVoxels} = data;\r\n            if (this.renderableToVoxelMapping.length === 0) {\r\n              // In this case it's likely that this is the first call with new scene data,\r\n              // in this case we just make it our direct mapping\r\n              this.renderableToVoxelMapping = mapping;\r\n            }\r\n            else {\r\n              Object.entries(mapping).forEach(entry => {\r\n                this.renderableToVoxelMapping[entry[0]] = entry[1];\r\n              });\r\n\r\n              // Update renderable to voxel mappings - we may no longer be rendering some of the assets that got updated \r\n              // if an asset changed positions to voxel(s) that this child doesn't render or vice versa)\r\n              const newRenderableToVoxelPtsMappings = {};\r\n              for (let i = 0; i < updatedRenderableVoxels.length; i++) {\r\n                const {voxelPt, renderableId} = updatedRenderableVoxels[i];\r\n\r\n                if (!(renderableId in newRenderableToVoxelPtsMappings)) {\r\n                  newRenderableToVoxelPtsMappings[renderableId] = [];\r\n                }\r\n\r\n                // If the voxel point is going to be rendered by this process then we include it\r\n                const voxelIdx = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_2__[\"default\"].voxelFlatIdx(voxelPt, this.rpScene.gridSize);\r\n                if (voxelIdx >= this.voxelIndexRange[0] && voxelIdx <= this.voxelIndexRange[1]) {\r\n                  newRenderableToVoxelPtsMappings[renderableId].push(voxelPt);\r\n                }\r\n              }\r\n\r\n              Object.entries(newRenderableToVoxelPtsMappings).forEach(entry => {\r\n                const [renderableId, voxelPts] = entry;\r\n                delete this.renderableToVoxelMapping[renderableId];\r\n                if (voxelPts.length > 0) {\r\n                  this.renderableToVoxelMapping[renderableId] = voxelPts;\r\n                }\r\n              });\r\n            }\r\n          }\r\n          \r\n          break;\r\n        }\r\n\r\n        case VTRenderProc.TO_PROC_RENDER:\r\n          this.rpScene.render(this.renderableToVoxelMapping);\r\n          break;\r\n\r\n        default:\r\n          console.error(`Invalid message type received by child render process: ${message.type}`);\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTRenderProc);\n\n//# sourceURL=webpack:///./src/VoxelTracer/RenderProc/VTRenderProc.js?");

/***/ }),

/***/ "./src/VoxelTracer/RenderProc/vtrenderprocess.js":
/*!*******************************************************!*\
  !*** ./src/VoxelTracer/RenderProc/vtrenderprocess.js ***!
  \*******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTRenderProc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTRenderProc */ \"./src/VoxelTracer/RenderProc/VTRenderProc.js\");\n\r\n\r\nconst renderProc = new _VTRenderProc__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\nrenderProc.run();\n\n//# sourceURL=webpack:///./src/VoxelTracer/RenderProc/vtrenderprocess.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js":
/*!******************************************************************!*\
  !*** ./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js ***!
  \******************************************************************/
/*! exports provided: DEFAULT_LEVEL_MAX, DEFAULT_GAMMA, DEFAULT_FADE_FACTOR, DEFAULT_LOW_COLOUR, DEFAULT_HIGH_COLOUR, DEFAULT_CENTER_SORTED, DEFAULT_SPLIT_LEVELS, POS_X_DIR, NEG_X_DIR, POS_Z_DIR, NEG_Z_DIR, DIRECTION_TYPES, LOW_HIGH_TEMP_COLOUR_MODE, TEMPERATURE_COLOUR_MODE, RANDOM_COLOUR_MODE, COLOUR_MODES, DEFAULT_SPEED, DEFAULT_DIR, historyBarsAudioVisDefaultConfig, basicBarsAudioVisDefaultConfig, fireAudioVisDefaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_LEVEL_MAX\", function() { return DEFAULT_LEVEL_MAX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_GAMMA\", function() { return DEFAULT_GAMMA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_FADE_FACTOR\", function() { return DEFAULT_FADE_FACTOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_LOW_COLOUR\", function() { return DEFAULT_LOW_COLOUR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_HIGH_COLOUR\", function() { return DEFAULT_HIGH_COLOUR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_CENTER_SORTED\", function() { return DEFAULT_CENTER_SORTED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_SPLIT_LEVELS\", function() { return DEFAULT_SPLIT_LEVELS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POS_X_DIR\", function() { return POS_X_DIR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NEG_X_DIR\", function() { return NEG_X_DIR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POS_Z_DIR\", function() { return POS_Z_DIR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NEG_Z_DIR\", function() { return NEG_Z_DIR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIRECTION_TYPES\", function() { return DIRECTION_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOW_HIGH_TEMP_COLOUR_MODE\", function() { return LOW_HIGH_TEMP_COLOUR_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TEMPERATURE_COLOUR_MODE\", function() { return TEMPERATURE_COLOUR_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RANDOM_COLOUR_MODE\", function() { return RANDOM_COLOUR_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLOUR_MODES\", function() { return COLOUR_MODES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_SPEED\", function() { return DEFAULT_SPEED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_DIR\", function() { return DEFAULT_DIR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"historyBarsAudioVisDefaultConfig\", function() { return historyBarsAudioVisDefaultConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"basicBarsAudioVisDefaultConfig\", function() { return basicBarsAudioVisDefaultConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fireAudioVisDefaultConfig\", function() { return fireAudioVisDefaultConfig; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Spectrum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Spectrum */ \"./src/Spectrum.js\");\n\r\n\r\n\r\nconst DEFAULT_LEVEL_MAX = 1.75;\r\nconst DEFAULT_GAMMA = 1.6;\r\nconst DEFAULT_FADE_FACTOR = 0.02;\r\nconst DEFAULT_LOW_COLOUR  = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](\"#99FC20\");\r\nconst DEFAULT_HIGH_COLOUR = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](\"#FD1999\"); \r\nconst DEFAULT_CENTER_SORTED = false;\r\nconst DEFAULT_SPLIT_LEVELS  = false;\r\n\r\nconst POS_X_DIR = \"+x\";\r\nconst NEG_X_DIR = \"-x\";\r\nconst POS_Z_DIR = \"+z\";\r\nconst NEG_Z_DIR = \"-z\";\r\n\r\nconst DIRECTION_TYPES = [\r\n  POS_X_DIR,\r\n  NEG_X_DIR,\r\n  POS_Z_DIR,\r\n  NEG_Z_DIR,\r\n];\r\n\r\n// Fire audio vis types\r\nconst LOW_HIGH_TEMP_COLOUR_MODE    = \"Low/High Temp\";\r\nconst TEMPERATURE_COLOUR_MODE      = \"Temperature\";\r\nconst RANDOM_COLOUR_MODE           = \"Random\";\r\n\r\nconst COLOUR_MODES = [\r\n  LOW_HIGH_TEMP_COLOUR_MODE,\r\n  TEMPERATURE_COLOUR_MODE,\r\n  RANDOM_COLOUR_MODE,\r\n];\r\n\r\nconst DEFAULT_SPEED = 5;\r\nconst DEFAULT_DIR = NEG_Z_DIR;\r\n\r\nconst historyBarsAudioVisDefaultConfig = {\r\n  lowColour:        DEFAULT_LOW_COLOUR.clone(),\r\n  highColour:       DEFAULT_HIGH_COLOUR.clone(),\r\n  colourInterpolationType: _Spectrum__WEBPACK_IMPORTED_MODULE_1__[\"COLOUR_INTERPOLATION_RGB\"],\r\n  speed:            DEFAULT_SPEED,\r\n  tempoMultiplier:  15.0,\r\n  direction:        DEFAULT_DIR,\r\n};\r\n\r\nconst basicBarsAudioVisDefaultConfig = {\r\n  lowColour:    DEFAULT_LOW_COLOUR,\r\n  highColour:   DEFAULT_HIGH_COLOUR,\r\n  colourInterpolationType: _Spectrum__WEBPACK_IMPORTED_MODULE_1__[\"COLOUR_INTERPOLATION_RGB\"],\r\n  centerSorted: DEFAULT_CENTER_SORTED,\r\n  splitLevels:  DEFAULT_SPLIT_LEVELS,\r\n};\r\n\r\nconst fireAudioVisDefaultConfig = {\r\n  initialIntensityMultiplier: 8,\r\n  speedMultiplier: 1.2,\r\n  coolingMultiplier: 0.9,\r\n  boyancyMultiplier: 0.6,\r\n  turbulenceMultiplier: 1,\r\n  colourMode: LOW_HIGH_TEMP_COLOUR_MODE,\r\n  lowTempColour:  new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0.2, 0, 1),\r\n  highTempColour: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1, 0, 0.7),\r\n  randomColourHoldTime: 5,\r\n  randomColourTransitionTime: 2,\r\n  temperatureMin: 100,\r\n  temperatureMax: 3000,\r\n  colourInterpolationType: _Spectrum__WEBPACK_IMPORTED_MODULE_1__[\"COLOUR_INTERPOLATION_HSL\"],\r\n  noise: 0.25,\r\n};\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/Audio/AudioVisUtils.js":
/*!*******************************************************!*\
  !*** ./src/VoxelTracer/Scenes/Audio/AudioVisUtils.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\n\r\nclass AudioVisUtils {\r\n\r\n  static buildBinIndexLookup(numFreqs, numBins, gamma) {\r\n    const binIndexLookup = {};\r\n    for (let i = 0; i < numFreqs; i++) {\r\n      let binIndex = Math.round(Math.pow(i/numFreqs, 1.0/gamma) * (numBins-1));\r\n      if (binIndex in binIndexLookup) {\r\n        binIndexLookup[binIndex].push(i);\r\n      }\r\n      else {\r\n        binIndexLookup[binIndex] = [i];\r\n      }\r\n    }\r\n\r\n    // Find gaps in the lookup and just have those gaps reference the previous (or next) bin's frequency(ies)\r\n    for (let i = 0; i < numBins; i++) {\r\n      if (i in binIndexLookup) {\r\n        continue;\r\n      }\r\n\r\n      // Is there a previous bin?\r\n      if (i-1 in binIndexLookup) {\r\n        binIndexLookup[i] = binIndexLookup[i-1];\r\n      }\r\n      // Is there a next bin?\r\n      else if (i+1 in binIndexLookup) {\r\n        binIndexLookup[i] = binIndexLookup[i+1];\r\n      }\r\n      else {\r\n        // This really shouldn't happen, it means there's a huge gap\r\n        console.error(\"Big gap in frequency to mesh data, please find me and write code to fix this issue.\");\r\n      }\r\n    }\r\n\r\n    return binIndexLookup;\r\n  }\r\n\r\n  static calcFFTBinLevelSum(binIndices, fft) {\r\n    let binLevel = 0;\r\n    for (let i = 0; i < binIndices.length; i++) {\r\n      binLevel += fft[binIndices[i]];\r\n    }\r\n    return binLevel;\r\n  }\r\n  static calcFFTBinLevelMax(binIndices, fft) {\r\n    let binLevel = 0;\r\n    for (let i = 0; i < binIndices.length; i++) {\r\n      binLevel = Math.max(binLevel, fft[binIndices[i]]);\r\n    }\r\n    return binLevel;\r\n  }\r\n\r\n  static buildSpiralIndices(xSize, ySize) {\r\n    const allIndices = {};\r\n    for (let x = 0; x < xSize; x++) {\r\n      for (let y = 0; y < ySize; y++) {\r\n        allIndices[x+\"_\"+y] = true;\r\n      }\r\n    }\r\n\r\n    let r = 1;\r\n\r\n    const gridSize = xSize*ySize;\r\n    const startX = Math.floor(xSize/2);\r\n    const startY = Math.floor(ySize/2);\r\n    const result = [];\r\n\r\n    while (result.length < gridSize) {\r\n      const rSqr = r*r;\r\n      for (let x = 0; x < xSize; x++) {\r\n        for (let y = 0; y < ySize; y++) {\r\n          const idx = x+\"_\"+y;\r\n          if (allIndices[idx]) {\r\n            let xDiff = x - startX;\r\n            let yDiff = y - startY;\r\n            if (xDiff*xDiff + yDiff*yDiff <= rSqr) {\r\n              result.push([x,y]);\r\n              allIndices[idx] = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      r++;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioVisUtils);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/Audio/AudioVisUtils.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/Audio/BasicBarsAudioVisScene.js":
/*!****************************************************************!*\
  !*** ./src/VoxelTracer/Scenes/Audio/BasicBarsAudioVisScene.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ \"chroma-js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AudioVisUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioVisUtils */ \"./src/VoxelTracer/Scenes/Audio/AudioVisUtils.js\");\n/* harmony import */ var _SceneRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SceneRenderer */ \"./src/VoxelTracer/Scenes/SceneRenderer.js\");\n/* harmony import */ var _VTVoxel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../VTVoxel */ \"./src/VoxelTracer/VTVoxel.js\");\n/* harmony import */ var _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../VTLambertMaterial */ \"./src/VoxelTracer/VTLambertMaterial.js\");\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AudioSceneDefaultConfigs */ \"./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass BasicBarsAudioVisScene extends _SceneRenderer__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n  constructor(scene, voxelModel) {\r\n    super(scene, voxelModel);\r\n    this._objectsBuilt = false;\r\n\r\n    this.timeCounter = 0;\r\n\r\n    this.lastAudioFrameTime = Date.now();\r\n    this.currAudioFrameTime = 0;\r\n\r\n    this.meshes = [];\r\n    this.spiralMeshIndices = [];\r\n    this.binIndexLookup = null;\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this._objectsBuilt = false;\r\n  }\r\n\r\n  build(options) {\r\n    const {sceneConfig} = options;\r\n    const splitLevels = sceneConfig.splitLevels ? sceneConfig.splitLevels : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__[\"DEFAULT_SPLIT_LEVELS\"];\r\n\r\n    if (!this._objectsBuilt || this._options.sceneConfig.splitLevels !== splitLevels) {\r\n\r\n      const { colourInterpolationType } = options.sceneConfig;\r\n\r\n      const lowColour = (sceneConfig.lowColour.r !== undefined && sceneConfig.lowColour.g && sceneConfig.lowColour.b) ?\r\n        sceneConfig.lowColour : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__[\"DEFAULT_LOW_COLOUR\"];\r\n      const highColour = (sceneConfig.highColour.r !== undefined && sceneConfig.highColour.g && sceneConfig.highColour.b) ?\r\n        sceneConfig.highColour : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__[\"DEFAULT_HIGH_COLOUR\"];\r\n\r\n      const ambientLightColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1);\r\n      this.ambientLight = new _VTAmbientLight__WEBPACK_IMPORTED_MODULE_6__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](ambientLightColour.r, ambientLightColour.g, ambientLightColour.b));\r\n\r\n      // Create a grid of cubes that we use to represent frequency levels for each FFT bin\r\n      const xSize = this.voxelModel.xSize();\r\n      const ySize = this.voxelModel.ySize();\r\n      const zSize = this.voxelModel.zSize();\r\n      const halfYSize = Math.floor(ySize/2);\r\n\r\n      this.meshes = [];\r\n      const Y_START = splitLevels ? halfYSize : 0;\r\n      const levelColours = [];\r\n      for (let y = Y_START; y < ySize; y++) {\r\n        const t = (y-Y_START) / (ySize-Y_START-1);\r\n        const temp = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(lowColour), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(highColour), t, colourInterpolationType).gl();\r\n        levelColours.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](temp[0], temp[1], temp[2]));\r\n      }\r\n\r\n      const voxelOptions = {receivesShadow: false};\r\n      \r\n      for (let x = 0; x < xSize; x++) {\r\n        for (let z = 0; z < zSize; z++) {\r\n          const levelMeshes = [];\r\n\r\n          if (splitLevels) {\r\n            const topLevelMeshes = [];\r\n            for (let y = Y_START; y < ySize; y++) {\r\n              const mesh = new _VTVoxel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z), new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"](levelColours[y-Y_START], 0), voxelOptions);\r\n              topLevelMeshes.push(mesh);\r\n            }\r\n\r\n            const bottomLevelMeshes = [];\r\n            for (let y = Y_START-1; y >= 0; y--) {\r\n              const mesh = new _VTVoxel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z), new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"](levelColours[Y_START-y-1], 0), voxelOptions);\r\n              bottomLevelMeshes.push(mesh);\r\n            }\r\n\r\n            levelMeshes.push(topLevelMeshes);\r\n            levelMeshes.push(bottomLevelMeshes);\r\n          }\r\n          else {\r\n            for (let y = Y_START; y < ySize; y++) {\r\n              const mesh = new _VTVoxel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z), new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"](levelColours[y-Y_START], 0), voxelOptions);\r\n              levelMeshes.push(mesh);\r\n            }\r\n          }\r\n          this.meshes.push(levelMeshes);\r\n        }\r\n      }\r\n\r\n      this._buildSpiralMeshIndices();\r\n      this.timeCounter = 0;\r\n      this._objectsBuilt = true;\r\n    }\r\n\r\n    this.scene.addLight(this.ambientLight);\r\n    for (let i = 0; i < this.meshes.length; i++) {\r\n      if (splitLevels) {\r\n        const levelMeshes = this.meshes[i];\r\n        const topLevelMeshes = levelMeshes[0];\r\n        const bottomLevelMeshes = levelMeshes[1];\r\n\r\n        for (let j = 0; j < topLevelMeshes.length; j++) {\r\n          this.scene.addObject(topLevelMeshes[j]);\r\n          this.scene.addObject(bottomLevelMeshes[j]);\r\n        }\r\n      }\r\n      else {\r\n        for (let j = 0; j < this.meshes[i].length; j++) {\r\n          this.scene.addObject(this.meshes[i][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _buildSpiralMeshIndices() {\r\n    const xSize = this.voxelModel.xSize();\r\n    const zSize = this.voxelModel.zSize();\r\n    const spiralXZIndices = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].buildSpiralIndices(xSize,zSize);\r\n\r\n    this.spiralMeshIndices = [];\r\n    for (let i = 0; i < spiralXZIndices.length; i++) {\r\n      const idx = spiralXZIndices[i][0]*zSize + spiralXZIndices[i][1];\r\n      this.spiralMeshIndices.push(idx);\r\n    }\r\n  }\r\n\r\n  async render(dt) {\r\n    if (!this._objectsBuilt) { return; }\r\n    this.timeCounter += dt;\r\n    await this.scene.render();\r\n  }\r\n\r\n  updateAudioInfo(audioInfo) {\r\n    this.currAudioFrameTime = Date.now();\r\n    const dt = (this.currAudioFrameTime - this.lastAudioFrameTime) / 1000;\r\n    this.lastAudioFrameTime = this.currAudioFrameTime;\r\n\r\n    const {sceneConfig} = this._options;\r\n\r\n    const levelMax = this._options.levelMax ? this._options.levelMax : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__[\"DEFAULT_LEVEL_MAX\"];\r\n    const gamma = this._options.gamma ? this._options.gamma : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__[\"DEFAULT_GAMMA\"];\r\n    const fadeFactor = this._options.fadeFactor ? this._options.fadeFactor : DEFAULT_FADE_FACTOR;\r\n\r\n    const centerSorted = sceneConfig.centerSorted !== undefined ? sceneConfig.centerSorted : DEFAULT_CENTER_SORTED;\r\n    const splitLevels = sceneConfig.splitLevels ? sceneConfig.splitLevels : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_8__[\"DEFAULT_SPLIT_LEVELS\"];\r\n\r\n    const fadeFactorAdjusted = Math.pow(fadeFactor, dt);\r\n\r\n    const {fft} = audioInfo;\r\n\r\n    const xSize = this.voxelModel.xSize();\r\n    //const ySize = this.voxelModel.ySize();\r\n    const zSize = this.voxelModel.zSize();\r\n    const gridSize = xSize*zSize;\r\n\r\n    let numFreqs = Math.floor(fft.length/(gamma+1.8));\r\n    if (fft.length >= gridSize && numFreqs < gridSize) {\r\n      numFreqs = gridSize;\r\n    }\r\n    else if (fft.length < gridSize) {\r\n      console.error(\"You need to implement grouped level blocks.\");\r\n    }\r\n\r\n    // Build a distribution of what bins (i.e., meshes) to throw each frequency in\r\n    if (!this.binIndexLookup || numFreqs !== this.binIndexLookup.length) {\r\n      this.binIndexLookup = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].buildBinIndexLookup(numFreqs, this.meshes.length, gamma);\r\n    }\r\n\r\n    // If the frequencies are center sorted, then we place the highest ones in the center of the base of the voxel grid, \r\n    // then move outwards with the lower ones\r\n    if (centerSorted) {\r\n      // First sort all of the frequency bins by their descending amplitudes\r\n      // (after we add all of the indices in the collective bin index lookup)\r\n      const collectedFFTs = Object.keys(this.binIndexLookup).map(idx => _AudioVisUtils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].calcFFTBinLevelSum(this.binIndexLookup[idx], fft));\r\n      collectedFFTs.sort((a,b) => b-a);\r\n    \r\n      // The spiral index list and the sorted fft list should be the same length.\r\n      //console.log(this.spiralMeshIndices.length);\r\n      //console.log(collectedFFTs.length);\r\n\r\n      // Now we iterate through the meshes starting from the center and spiraling outward\r\n      for (let i = 0; i < this.spiralMeshIndices.length; i++) {\r\n        const currMeshIdx = this.spiralMeshIndices[i];\r\n        const levelMeshes = this.meshes[currMeshIdx];\r\n        const binLevel = collectedFFTs[i];\r\n        this._updateMeshLevels(binLevel, levelMax, fadeFactorAdjusted, levelMeshes, splitLevels);\r\n      }\r\n\r\n    }\r\n    else {\r\n      for (let i = 0; i < this.meshes.length; i++) {\r\n        const fftIndices = this.binIndexLookup[i];\r\n        const binLevel = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].calcFFTBinLevelSum(fftIndices, fft);\r\n        const levelMeshes = this.meshes[i];\r\n        this._updateMeshLevels(binLevel, levelMax, fadeFactorAdjusted, levelMeshes, splitLevels);\r\n      }\r\n    }\r\n  }\r\n\r\n  _updateMeshLevels(binLevel, levelMax, fadeFactorAdjusted, levelMeshes, splitLevels) {\r\n    const updateLevel = (cutoffLvl, lvlMeshes) => {\r\n      for (let k = 0; k < lvlMeshes.length; k++) {\r\n        const alpha = k < cutoffLvl ? 1 : 0;\r\n        const mesh = lvlMeshes[k];\r\n        const {material} = mesh;\r\n        material.alpha = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(material.alpha * fadeFactorAdjusted + alpha * (1.0 - fadeFactorAdjusted), 0, 1);\r\n        mesh.setMaterial(material);\r\n      }\r\n    };\r\n\r\n    if (splitLevels) {\r\n      const topLevelMeshes = levelMeshes[0];\r\n      const bottomLevelMeshes = levelMeshes[1];\r\n      const cutoffLevel = Math.floor(Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(Math.log10(binLevel)/levelMax,0,1) * (topLevelMeshes.length));\r\n      updateLevel(cutoffLevel, topLevelMeshes);\r\n      updateLevel(cutoffLevel, bottomLevelMeshes);\r\n    }\r\n    else {\r\n      const cutoffLevel = Math.floor(Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(Math.log10(binLevel)/levelMax,0,1) * (levelMeshes.length));\r\n      updateLevel(cutoffLevel, levelMeshes);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (BasicBarsAudioVisScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/Audio/BasicBarsAudioVisScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/Audio/FireAudioVisScene.js":
/*!***********************************************************!*\
  !*** ./src/VoxelTracer/Scenes/Audio/FireAudioVisScene.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ \"chroma-js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _SceneRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../SceneRenderer */ \"./src/VoxelTracer/Scenes/SceneRenderer.js\");\n/* harmony import */ var _AudioVisUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AudioVisUtils */ \"./src/VoxelTracer/Scenes/Audio/AudioVisUtils.js\");\n/* harmony import */ var _VTVoxel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../VTVoxel */ \"./src/VoxelTracer/VTVoxel.js\");\n/* harmony import */ var _VTEmissionMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../VTEmissionMaterial */ \"./src/VoxelTracer/VTEmissionMaterial.js\");\n/* harmony import */ var _Fluid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../Fluid */ \"./src/Fluid.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Spectrum__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../Spectrum */ \"./src/Spectrum.js\");\n/* harmony import */ var _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../Animation/Randomizers */ \"./src/Animation/Randomizers.js\");\n/* harmony import */ var _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AudioSceneDefaultConfigs */ \"./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst FIRE_THRESHOLD = 7;\r\nconst MAX_FIRE_ALPHA = 1.0;\r\nconst FULL_ON_FIRE   = 100;\r\n\r\nclass FireAudioVisScene extends _SceneRenderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n  constructor(scene, voxelModel) {\r\n    super(scene, voxelModel);\r\n    this._objectsBuilt = false;\r\n    \r\n    // Setup basic defaults for the fire's fluid model - these will immediately be modified based on the audio\r\n    this.fluidModel = new _Fluid__WEBPACK_IMPORTED_MODULE_6__[\"default\"](voxelModel.gridSize);\r\n    this.fluidModel.diffusion = 0.0001;\r\n    this.fluidModel.viscosity = 0;\r\n    this.fluidModel.buoyancy  = 5.4;\r\n    this.fluidModel.cooling   = 1.3;\r\n    this.fluidModel.vc_eps    = 8;\r\n\r\n    this.colourTransitionTimeCounter = 0;\r\n    this.colourHoldTimeCounter = 0;\r\n    this.currRandomColours = this._genRandomFireColours();\r\n    this.nextRandomColours = this._genRandomFireColours(this.currRandomColours);\r\n\r\n    this.t = 0;\r\n    this.avgSpectralCentroid = 0;\r\n    this.avgNormalizedSpectralCentroid = 0;\r\n    this.avgRMS = 0;\r\n    this.lastAudioFrameTime = Date.now();\r\n    this.currAudioFrameTime = this.lastAudioFrameTime;\r\n    this.dRMSAvg = 0;\r\n    this.avgBeatsPerSec = 0;\r\n    this.lastdRMS = 0;\r\n    this.avgBeatsPerSec = 0;\r\n    this.timeSinceLastBeat = 1;\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this._objectsBuilt = false;\r\n  }\r\n\r\n  build(options) {\r\n    const {noise} = options.sceneConfig;\r\n\r\n    const xSize = this.voxelModel.xSize();\r\n    const ySize = this.voxelModel.ySize();\r\n    const zSize = this.voxelModel.zSize();\r\n\r\n    this.initArray = _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloats(xSize*zSize);\r\n    this.randomArray = _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloats(xSize*zSize, 0, noise);\r\n    //console.log(this.randomArray);\r\n\r\n    if (!this._objectsBuilt) {\r\n\r\n      //this.spiralIndices = AudioVisUtils.buildSpiralIndices(xSize, zSize);\r\n\r\n      this.voxels = new Array(xSize);\r\n      for (let x = 0; x < xSize; x++) {\r\n        const yVoxels = new Array(ySize);\r\n        this.voxels[x] = yVoxels;\r\n        for (let y = 0; y < ySize; y++) {\r\n          const zVoxels = new Array(zSize);\r\n          yVoxels[y] = zVoxels;\r\n          for (let z = 0; z < zSize; z++) {\r\n            zVoxels[z] = new _VTVoxel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z), new _VTEmissionMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0), 1));\r\n          }\r\n        }\r\n      }\r\n\r\n      this._objectsBuilt = true;\r\n    }\r\n\r\n    for (let x = 0; x < xSize; x++) {\r\n      for (let y = 0; y < ySize; y++) {\r\n        for (let z = 0; z < zSize; z++) {\r\n          this.scene.addObject(this.voxels[x][y][z]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async render(dt) {\r\n    if (!this._objectsBuilt) { return; }\r\n\r\n    const {\r\n      speedMultiplier, \r\n      initialIntensityMultiplier, \r\n      randomColourHoldTime,\r\n      randomColourTransitionTime,\r\n      colourMode,\r\n      highTempColour, lowTempColour,\r\n      colourInterpolationType\r\n    } = this._options.sceneConfig;\r\n\r\n    const xSize = this.voxelModel.xSize();\r\n    const ySize = this.voxelModel.ySize();\r\n    const zSize = this.voxelModel.zSize();\r\n\r\n    const startX = 1;\r\n    const endX = xSize+1;\r\n    const startZ = 1;\r\n    const endZ = zSize+1;\r\n    const startY = 1;\r\n\r\n    //const fluidTemperatures = new Array((endX-startX)*(endZ-startZ));\r\n    //let idxCount = 0;\r\n\r\n    for (let x = startX; x < endX; x++) {\r\n      for (let z = startZ; z < endZ; z++) {\r\n        let f = this._genFunc(x-startX, z-startZ, endX-startX, endZ-startZ, this.t, this.initArray);\r\n        const idx = this.fluidModel._I(x, startY, z);\r\n        this.fluidModel.sd[idx] = 1.0;\r\n        this.fluidModel.sT[idx] = (1.0 + f*initialIntensityMultiplier);\r\n      }\r\n    }\r\n    /*\r\n    // Sort the fluid model starting points by highest to lowest from the center spiraling outward\r\n    fluidTemperatures.sort((a,b) => b-a);\r\n    idxCount = 0;\r\n    for (let i = 0; i < this.spiralIndices.length; i++) {\r\n      const sIdx = this.spiralIndices[i];\r\n      const x = sIdx[0];\r\n      const z = sIdx[1];\r\n      if (x >= startX && x < endX && z >= startZ && z < endZ) {\r\n        const fIdx = this.fluidModel._I(x, startY, z);\r\n        this.fluidModel.sT[fIdx] = fluidTemperatures[idxCount++];\r\n      }\r\n    }\r\n    */\r\n    const currSpeed = 2 + speedMultiplier * (1 + Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smootherstep(this.avgBeatsPerSec, 0, 80), 0, 0.75));\r\n    const speedDt = dt*currSpeed;\r\n    this.fluidModel.step(speedDt);\r\n    this.t += speedDt;\r\n\r\n    let fireLookupFunc = null;\r\n    switch (colourMode) {\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_10__[\"TEMPERATURE_COLOUR_MODE\"]:\r\n        fireLookupFunc = this._fireFuncGenTemperature();\r\n        break;\r\n\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_10__[\"RANDOM_COLOUR_MODE\"]: {\r\n        let finalLowTempColour  = this.currRandomColours.lowTempColour;\r\n        let finalHighTempColour = this.currRandomColours.highTempColour;\r\n\r\n        if (this.colourHoldTimeCounter >= randomColourHoldTime) {\r\n          // We're transitioning between random colours, interpolate from the previous to the next\r\n          const interpolationVal = this.colourTransitionTimeCounter/randomColourTransitionTime;\r\n          const tempLowTempColour = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.currRandomColours.lowTempColour), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.nextRandomColours.lowTempColour), interpolationVal, colourInterpolationType).gl();\r\n          finalLowTempColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](tempLowTempColour[0], tempLowTempColour[1], tempLowTempColour[2]);\r\n          const tempHighTempColour = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.currRandomColours.highTempColour), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(this.nextRandomColours.highTempColour), interpolationVal, colourInterpolationType).gl();\r\n          finalHighTempColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](tempHighTempColour[0], tempHighTempColour[1], tempHighTempColour[2]);\r\n        \r\n          if (this.colourTransitionTimeCounter >= randomColourTransitionTime) {\r\n            this.currRandomColours.lowTempColour  = this.nextRandomColours.lowTempColour;\r\n            this.currRandomColours.highTempColour = this.nextRandomColours.highTempColour;\r\n            this.nextRandomColours = this._genRandomFireColours(this.currRandomColours);\r\n            this.colourTransitionTimeCounter -= randomColourTransitionTime;\r\n            this.colourHoldTimeCounter -= randomColourHoldTime;\r\n          }\r\n          this.colourTransitionTimeCounter += dt;\r\n        }\r\n        else {\r\n          this.colourHoldTimeCounter += dt;\r\n        }\r\n\r\n        fireLookupFunc = this._fireFuncGenHighLow(finalHighTempColour, finalLowTempColour);\r\n        break;\r\n      }\r\n\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_10__[\"LOW_HIGH_TEMP_COLOUR_MODE\"]:\r\n      default:\r\n        fireLookupFunc = this._fireFuncGenHighLow(highTempColour, lowTempColour);\r\n        break;\r\n    }\r\n\r\n    // Update the voxels and render them\r\n    for (let x = 0; x < xSize; x++) {\r\n      for (let y = 0; y < ySize; y++) {\r\n        for (let z = 0; z < zSize; z++) {\r\n\r\n          // Start by looking up the temperature and density of the flame, both are constrained in [0,1]\r\n          const idx = this.fluidModel._I(x+startX,y+startY,z+startZ);\r\n          const temperature = this.fluidModel.T[idx];\r\n          const density = this.fluidModel.d[idx];\r\n          //const lighting = 0.0;\r\n\r\n          // Use the temp and density to look up the expected colour of the flame at the current voxel\r\n          const temperatureIdx = Math.min(_Spectrum__WEBPACK_IMPORTED_MODULE_8__[\"FIRE_SPECTRUM_WIDTH\"]-1, Math.max(0, Math.round(temperature*(_Spectrum__WEBPACK_IMPORTED_MODULE_8__[\"FIRE_SPECTRUM_WIDTH\"]-1))));\r\n          const densityIdx = Math.min(15, Math.max(0, Math.round(density*15)));\r\n          const intensityIdx = 0;//Math.round(lighting*15);\r\n\r\n          const voxelColour = fireLookupFunc(intensityIdx, densityIdx, temperatureIdx);\r\n          const voxel =  this.voxels[x][y][z];\r\n          const voxelMaterial = voxel.material;\r\n          voxelMaterial.colour.setRGB(voxelColour.a*voxelColour.r, voxelColour.a*voxelColour.g, voxelColour.a*voxelColour.b)\r\n          voxel.makeDirty();\r\n        }\r\n      }\r\n    }\r\n\r\n    await this.scene.render();\r\n  }\r\n\r\n  updateAudioInfo(audioInfo) {\r\n    const {gamma, levelMax} = this._options;\r\n    const {boyancyMultiplier, coolingMultiplier, turbulenceMultiplier} = this._options.sceneConfig;\r\n    const {fft, rms, spectralCentroid} = audioInfo;\r\n\r\n    // Use the FFT array to populate the initialization array for the fire\r\n    let numFreqs = Math.floor(fft.length/(gamma+1.8));\r\n\r\n    // Build a distribution of what bins (i.e., meshes) to throw each frequency in\r\n    if (!this.binIndexLookup || numFreqs !== this.binIndexLookup.length) {\r\n      this.binIndexLookup = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].buildBinIndexLookup(numFreqs, this.initArray.length, gamma);\r\n    }\r\n\r\n    for (let i = 0; i < this.initArray.length; i++) {\r\n      const fftIndices = this.binIndexLookup[i];\r\n      const binLevel = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].calcFFTBinLevelMax(fftIndices, fft);\r\n      this.initArray[i] = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(Math.log10(binLevel)/levelMax, 0, 1);\r\n    }\r\n    //console.log(this.initArray);\r\n\r\n    // Update the fluid model levers based on the current audio\r\n    const denoisedRMS = rms < 0.01 ? 0 : rms;\r\n    this.avgRMS = (this.avgRMS + denoisedRMS) / 2.0;\r\n    this.avgSpectralCentroid = (this.avgSpectralCentroid + spectralCentroid) / 2.0;\r\n    this.avgNormalizedSpectralCentroid = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(this.avgSpectralCentroid / (fft.length / 2), 0, 1);\r\n    const boyancyVal = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(this.avgNormalizedSpectralCentroid * 10, 1, 5);\r\n    //console.log(boyancyVal);\r\n    //console.log(this.avgNormalizedSpectralCentroid);\r\n    //console.log(this.avgRMS);\r\n\r\n    this.fluidModel.diffusion = 0.0001;\r\n    this.fluidModel.viscosity = 0;\r\n    this.fluidModel.buoyancy  = boyancyVal * boyancyMultiplier;\r\n    this.fluidModel.cooling   = 0.1 + (1.0 - this.avgRMS) * 1.1 * coolingMultiplier; // Values range from [0.1, 2] where lower values make the fire brighter/bigger\r\n    this.fluidModel.vc_eps = this.avgRMS * 40 * turbulenceMultiplier;\r\n\r\n    this.currAudioFrameTime = Date.now();\r\n    const dt = (this.currAudioFrameTime - this.lastAudioFrameTime) / 1000;\r\n    this.lastAudioFrameTime = this.currAudioFrameTime;\r\n\r\n    this.dRMSAvg = (this.dRMSAvg + (denoisedRMS - this.lastRMS) / dt) / 2.0;\r\n    if (this.timeSinceLastBeat > 0.001 && (this.dRMSAvg < 0 && this.lastdRMS > 0) || (this.dRMSAvg > 0 && this.lastdRMS < 0)) {\r\n      // We crossed zero, count the beat\r\n      this.avgBeatsPerSec = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])((this.avgBeatsPerSec + 1.0 / this.timeSinceLastBeat) / 2.0, 0, 80);\r\n      this.timeSinceLastBeat = 0;\r\n    }\r\n    else {\r\n      this.timeSinceLastBeat += dt;\r\n      if (this.timeSinceLastBeat > 1) {\r\n        this.avgBeatsPerSec = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])((this.avgBeatsPerSec + 0.01) / 2.0, 0, 80);\r\n      }\r\n    }\r\n    \r\n    this.lastRMS  = denoisedRMS;\r\n    this.lastdRMS = this.dRMSAvg;\r\n  }\r\n\r\n  _genRandomFireColours(currRandomColours=null) {\r\n    const BRIGHTEN_FACTOR = [0, 1];\r\n    const LOW_TEMP_SATURATION = [0.75, 1.0];\r\n    const LOW_TEMP_INTENSITY  = [0.33, 0.66];\r\n    const HUE_DISTANCE_FROM_LOW_TEMP = [90,270];\r\n\r\n    let nextHighTempColour = null;\r\n    let nextLowTempColour  = null;\r\n\r\n    const brightenFactor = _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloat(BRIGHTEN_FACTOR[0], BRIGHTEN_FACTOR[1]);\r\n\r\n    if (currRandomColours) {\r\n      // Use the existing random colours as a jump-off point to make sure we don't repeat them consecutively\r\n      const lowTempChromaHsi  = chroma_js__WEBPACK_IMPORTED_MODULE_1___default()(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(currRandomColours.lowTempColour)).hsi();\r\n\r\n      lowTempChromaHsi[0] = (lowTempChromaHsi[0] + _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomInt(60,300)) % 360;\r\n      lowTempChromaHsi[1] = _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloat(LOW_TEMP_SATURATION[0], LOW_TEMP_SATURATION[1]);\r\n      lowTempChromaHsi[2] = _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloat(LOW_TEMP_INTENSITY[0], LOW_TEMP_INTENSITY[1]);\r\n\r\n      const highTempChromaHsi = [\r\n        (lowTempChromaHsi[0] + _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomInt(HUE_DISTANCE_FROM_LOW_TEMP[0], HUE_DISTANCE_FROM_LOW_TEMP[1])) % 360, \r\n        1, lowTempChromaHsi[2]\r\n      ];\r\n      nextLowTempColour = chroma_js__WEBPACK_IMPORTED_MODULE_1___default()(lowTempChromaHsi, 'hsi').gl();\r\n      nextLowTempColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](nextLowTempColour[0], nextLowTempColour[1], nextLowTempColour[2]);\r\n      nextHighTempColour = chroma_js__WEBPACK_IMPORTED_MODULE_1___default()(highTempChromaHsi, 'hsi').brighten(brightenFactor).gl();\r\n      nextHighTempColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](nextHighTempColour[0], nextHighTempColour[1], nextHighTempColour[2]);\r\n    }\r\n    else {\r\n      // First time generation, pick some good random colours\r\n      const lowTempChroma = chroma_js__WEBPACK_IMPORTED_MODULE_1___default()(\r\n        _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomInt(0,360),\r\n        _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloat(LOW_TEMP_SATURATION[0], LOW_TEMP_SATURATION[1]),\r\n        _Animation_Randomizers__WEBPACK_IMPORTED_MODULE_9__[\"Randomizer\"].getRandomFloat(LOW_TEMP_INTENSITY[0], LOW_TEMP_INTENSITY[1]), 'hsi');\r\n      let temp = lowTempChroma.gl();\r\n      nextLowTempColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](temp[0], temp[1], temp[2]);\r\n      //console.log(\"low: \" + temp);\r\n      \r\n      let lowTempHsi = lowTempChroma.hsi();\r\n      //console.log(\"low temp Hsi: \" + lowTempHsi);\r\n      const highTempChroma = chroma_js__WEBPACK_IMPORTED_MODULE_1___default()((lowTempHsi[0] + 180) % 360, 1, lowTempHsi[2], 'hsi').brighten(brightenFactor);\r\n      temp = highTempChroma.gl();\r\n      nextHighTempColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](temp[0], temp[1], temp[2]);\r\n      //console.log(\"high: \" + temp);\r\n    }\r\n\r\n    return {\r\n      highTempColour: nextHighTempColour,\r\n      lowTempColour: nextLowTempColour\r\n    };\r\n  }\r\n\r\n  _fireFuncGenTemperature() {\r\n    return (intensityIdx, densityIdx, temperatureIdx) => {\r\n      if (temperatureIdx < FIRE_THRESHOLD) {\r\n        return { r: 0, g: 0, b: 0, a: 0 };\r\n      }\r\n\r\n      const {temperatureMin, temperatureMax} = this._options.sceneConfig;\r\n\r\n      const intensityCoeff = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smoothstep(intensityIdx, 0, 15);\r\n      const densityCoeff   = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smoothstep(densityIdx, 0, 15);\r\n      const brightenAmt    = intensityCoeff * 2;\r\n      const desaturateAmt  = densityCoeff * 2;\r\n\r\n      const temperatureNorm = temperatureIdx / (_Spectrum__WEBPACK_IMPORTED_MODULE_8__[\"FIRE_SPECTRUM_WIDTH\"] - 1);\r\n      const temperature = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].lerp(temperatureMin, temperatureMax, temperatureNorm) + \r\n        100 * brightenAmt - 100 * desaturateAmt;\r\n      const finalColour = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.temperature(temperature).gl();\r\n\r\n      return {\r\n        r: finalColour[0],\r\n        g: finalColour[1],\r\n        b: finalColour[2],\r\n        a: this._fireAlpha(temperatureIdx)\r\n      };\r\n    };\r\n  }\r\n\r\n  _fireFuncGenHighLow(highTempColour, lowTempColour) {\r\n    return (intensityIdx, densityIdx, temperatureIdx) => {\r\n      if (temperatureIdx < FIRE_THRESHOLD) {\r\n        return {r: 0, g:0, b:0, a:0};\r\n      }\r\n  \r\n      const {colourInterpolationType} = this._options.sceneConfig;\r\n      const intensityCoeff = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smoothstep(intensityIdx, 0, 15);\r\n      const densityCoeff = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smoothstep(densityIdx, 0, 15);\r\n\r\n      const brightenAmt = intensityCoeff*2;\r\n      const desaturateAmt = densityCoeff*2;\r\n\r\n      const lowTempColourWithAlpha  = { r: lowTempColour.r,  g: lowTempColour.g,  b: lowTempColour.b,  a: 1 };\r\n      const highTempColourWithAlpha = { r: highTempColour.r, g: highTempColour.g, b: highTempColour.b, a: 1 };\r\n\r\n      const finalColour = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(\r\n        chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(lowTempColourWithAlpha), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(highTempColourWithAlpha), \r\n        temperatureIdx / (_Spectrum__WEBPACK_IMPORTED_MODULE_8__[\"FIRE_SPECTRUM_WIDTH\"] - 1), colourInterpolationType\r\n      ).brighten(brightenAmt).desaturate(desaturateAmt).gl();\r\n\r\n      return {\r\n        r: finalColour[0],\r\n        g: finalColour[1],\r\n        b: finalColour[2],\r\n        a: this._fireAlpha(temperatureIdx)\r\n      };\r\n    }\r\n  }\r\n\r\n  _fireAlpha(temperatureIdx) {\r\n    return MAX_FIRE_ALPHA * ((temperatureIdx > FULL_ON_FIRE) ? 1.0 : \r\n      (temperatureIdx-FIRE_THRESHOLD) / (FULL_ON_FIRE-FIRE_THRESHOLD));\r\n  }\r\n\r\n  _genFunc(x, y, sx, sy, t, p) {\r\n    const {noise} = this._options.sceneConfig;\r\n    let avgP = 0;\r\n    let maxP = 0;\r\n    for (let j = 0; j < p.length; j++) {\r\n      avgP += p[j];\r\n      maxP = Math.max(maxP, p[j]);\r\n    }\r\n    avgP /= p.length;\r\n\r\n    const multiplier = Math.max(avgP, noise/4);\r\n\r\n    let f = 0;\r\n    let i = 0;\r\n    \r\n    let pIdx = 0;\r\n    const calcP = () => {\r\n      const result = p[pIdx] + this.randomArray[pIdx];\r\n      pIdx = (pIdx + 1) % p.length;\r\n      return Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(result, 0, 1);\r\n    };\r\n\r\n    for (; i < 12; i++) {\r\n      f += (1.0 +\r\n        Math.sin(x/sx*_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"PI2\"]*(calcP()+1)+(calcP())*_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"PI2\"] + (calcP())*t) *\r\n        Math.sin(y/sy*_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"PI2\"]*(calcP()+1)+(calcP())*_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"PI2\"] + (calcP())*t)) *\r\n        (1 + Math.sin((calcP()+0.5)*t + (calcP())*_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"PI2\"])) * multiplier;\r\n    }\r\n    f /= i;\r\n\r\n    let fx = (x < sx*0.9) ? 1.0 : 1.0-(x-sx*0.9)/(sx*0.2);\r\n    if (x < sx*0.1) {\r\n      fx = 0.5 + x/(sx*0.2);\r\n    }\r\n    let fy = (y < sy*0.9) ? 1.0 : 1.0-(y-sy*0.9)/(sy*0.2);\r\n    if (y < sy*0.1) {\r\n      fy = 0.5 + y/(sy*0.2);\r\n    }\r\n\r\n    return f * fx * fy;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FireAudioVisScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/Audio/FireAudioVisScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/Audio/HistoryBarsAudioVisScene.js":
/*!******************************************************************!*\
  !*** ./src/VoxelTracer/Scenes/Audio/HistoryBarsAudioVisScene.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ \"chroma-js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioSceneDefaultConfigs */ \"./src/VoxelTracer/Scenes/Audio/AudioSceneDefaultConfigs.js\");\n/* harmony import */ var _SceneRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SceneRenderer */ \"./src/VoxelTracer/Scenes/SceneRenderer.js\");\n/* harmony import */ var _VTVoxel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../VTVoxel */ \"./src/VoxelTracer/VTVoxel.js\");\n/* harmony import */ var _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../VTLambertMaterial */ \"./src/VoxelTracer/VTLambertMaterial.js\");\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _AudioVisUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AudioVisUtils */ \"./src/VoxelTracer/Scenes/Audio/AudioVisUtils.js\");\n/* harmony import */ var _VTPointLight__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../VTPointLight */ \"./src/VoxelTracer/VTPointLight.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst ptLightDistFromFront = 10;\r\n\r\nclass HistoryBarsAudioVisScene extends _SceneRenderer__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n  constructor(scene, voxelModel) {\r\n    super(scene, voxelModel);\r\n    this._objectsBuilt = false;\r\n\r\n    this.timeCounter = 0;\r\n\r\n    this.lastAudioFrameTime = Date.now();\r\n    this.currAudioFrameTime = 0;\r\n    this.audioFrameBuffer  = [];\r\n\r\n    this.meshes = [];\r\n    this.binIndexLookup = null;\r\n\r\n    this.dRMSAvg = 0;\r\n    this.lastdRMS = 0;\r\n    this.lastRMS = 0;\r\n    this.avgBeatsPerSec = 0;\r\n    this.avgSpectralCentroid = 0;\r\n    this.timeSinceLastBeat = 0;\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this._objectsBuilt = false;\r\n  }\r\n\r\n  build(options) {\r\n    const {sceneConfig} = options;\r\n    \r\n    if (!this._objectsBuilt) {\r\n\r\n      const { colourInterpolationType } = options.sceneConfig;\r\n\r\n      const lowColour = (sceneConfig.lowColour.r !== undefined && sceneConfig.lowColour.g && sceneConfig.lowColour.b) ?\r\n        sceneConfig.lowColour : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_LOW_COLOUR\"];\r\n      const highColour = (sceneConfig.highColour.r !== undefined && sceneConfig.highColour.g && sceneConfig.highColour.b) ?\r\n        sceneConfig.highColour : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_HIGH_COLOUR\"];\r\n      const direction  = sceneConfig.direction  ? sceneConfig.direction  : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_DIR\"];\r\n      \r\n      const ambientLightColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1);\r\n      this.ambientLight = new _VTAmbientLight__WEBPACK_IMPORTED_MODULE_6__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](ambientLightColour.r, ambientLightColour.g, ambientLightColour.b));\r\n\r\n      // Create a grid of cubes that we use to represent frequency levels for each FFT bin\r\n      const xSize = this.voxelModel.xSize();\r\n      const ySize = this.voxelModel.ySize();\r\n      const zSize = this.voxelModel.zSize();\r\n\r\n      let voxelCoordFunc = null;\r\n      let ptLightPos = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n      \r\n      switch (direction) {\r\n        case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"POS_X_DIR\"]:\r\n          voxelCoordFunc = (x,y,z) => new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](x,y,z);\r\n          ptLightPos.set(-ptLightDistFromFront, ySize/2 + 0.5, zSize/2 - 0.5);\r\n          break;\r\n        case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"NEG_X_DIR\"]:\r\n          voxelCoordFunc = (x,y,z) => new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](xSize-x-1,y,z);\r\n          ptLightPos.set(xSize + ptLightDistFromFront, ySize/2 + 0.5, zSize/2 - 0.5);\r\n          break;\r\n        case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"POS_Z_DIR\"]:\r\n          voxelCoordFunc = (x,y,z) => new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](z,y,x);\r\n          ptLightPos.set(xSize/2 - 0.5, ySize/2 + 0.5, -ptLightDistFromFront);\r\n          break;\r\n        case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"NEG_Z_DIR\"]:\r\n        default:\r\n          voxelCoordFunc = (x,y,z) => new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](z,y,xSize-x-1);\r\n          ptLightPos.set(xSize/2 - 0.5, ySize/2 + 0.5, zSize+ptLightDistFromFront);\r\n          break;\r\n      }\r\n\r\n      this.spectralPtLight = new _VTPointLight__WEBPACK_IMPORTED_MODULE_9__[\"default\"](ptLightPos, new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0), {quadratic:0.5, linear:0, constant:0});\r\n\r\n      this.meshes = [];\r\n      const Y_START = 0;\r\n      const levelColours = [];\r\n      for (let y = Y_START; y < ySize; y++) {\r\n        const t = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smootherstep(y, Y_START, ySize-1);\r\n        const temp = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.mix(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(lowColour), chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.gl(highColour), t, colourInterpolationType).gl();\r\n        levelColours.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](temp[0], temp[1], temp[2]));\r\n      }\r\n      \r\n      const voxelOptions = {receivesShadow: false};\r\n      for (let x = 0; x < xSize; x++) {\r\n        for (let z = 0; z < zSize; z++) {\r\n          const levelMeshes = [];        \r\n          for (let y = Y_START; y < ySize; y++) {\r\n            const mesh = new _VTVoxel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](voxelCoordFunc(x,y,z), new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"](levelColours[y-Y_START], 0, null, true), voxelOptions);\r\n            levelMeshes.push(mesh);\r\n          }\r\n          this.meshes.push(levelMeshes);\r\n        }\r\n      }\r\n\r\n      // Build an empty audio framebuffer\r\n      this.audioFrameBuffer = [];\r\n      for (let i = 0; i < xSize; i++) {\r\n        this.audioFrameBuffer.push(new Array(zSize).fill(0));\r\n      }\r\n\r\n      this.timeCounter = 0;\r\n      this._objectsBuilt = true;\r\n    }\r\n\r\n    this.scene.addLight(this.ambientLight);\r\n    this.scene.addLight(this.spectralPtLight);\r\n    for (let i = 0; i < this.meshes.length; i++) {\r\n      for (let j = 0; j < this.meshes[i].length; j++) {\r\n        this.scene.addObject(this.meshes[i][j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  async render(dt) {\r\n    if (!this._objectsBuilt) { return; }\r\n    await this.scene.render();\r\n  }\r\n\r\n  updateAudioInfo(audioInfo) {\r\n\r\n    this.currAudioFrameTime = Date.now();\r\n    const dt = (this.currAudioFrameTime - this.lastAudioFrameTime) / 1000;\r\n    this.lastAudioFrameTime = this.currAudioFrameTime;\r\n\r\n    const {sceneConfig} = this._options;\r\n\r\n    const levelMax = this._options.levelMax ? this._options.levelMax : 1.5;\r\n    const gamma = this._options.gamma ? this._options.gamma : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_GAMMA\"];\r\n    const fadeFactor = this._options.fadeFactor ? this._options.fadeFactor : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_FADE_FACTOR\"];\r\n    const speed = sceneConfig.speed ? sceneConfig.speed : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_SPEED\"];\r\n    const tempoMultiplier = sceneConfig.tempoMultiplier ? sceneConfig.tempoMultiplier : 1;\r\n    const direction  = sceneConfig.direction  ? sceneConfig.direction  : _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_DIR\"]; \r\n\r\n    const {fft, rms, spectralCentroid} = audioInfo;\r\n\r\n    this.avgSpectralCentroid = (this.avgSpectralCentroid + spectralCentroid) / 2.0;\r\n\r\n    const denoisedRMS = rms < 0.01 ? 0 : rms;\r\n    this.dRMSAvg = (this.dRMSAvg + (denoisedRMS - this.lastRMS) / dt) / 2.0;\r\n    if (this.timeSinceLastBeat > 0.0001 && (this.dRMSAvg < 0 && this.lastdRMS > 0) || (this.dRMSAvg > 0 && this.lastdRMS < 0)) {\r\n      // We crossed zero, count the beat\r\n      this.avgBeatsPerSec = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])((this.avgBeatsPerSec + 1.0 / this.timeSinceLastBeat) / 2.0, 0, 80);\r\n      this.timeSinceLastBeat = 0;\r\n    }\r\n    else {\r\n      this.timeSinceLastBeat += dt;\r\n      if (this.timeSinceLastBeat > 1) {\r\n        this.avgBeatsPerSec = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])((this.avgBeatsPerSec + 0.01) / 2.0, 0, 80);\r\n      }\r\n    }\r\n\r\n    this.lastRMS  = denoisedRMS;\r\n    this.lastdRMS = this.dRMSAvg;\r\n  \r\n    const xSize = this.voxelModel.xSize();\r\n    const zSize = this.voxelModel.zSize();\r\n    let loopSize = zSize;\r\n    let minSpectralCoord = 0;\r\n    let maxSpectralCoord = zSize-1;\r\n    let spectralComponent = 'z';\r\n    switch (direction) {\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"POS_X_DIR\"]:\r\n        loopSize = zSize;\r\n        minSpectralCoord = 0;\r\n        maxSpectralCoord = zSize-1;\r\n        spectralComponent = 'z';\r\n        break;\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"NEG_X_DIR\"]:\r\n        minSpectralCoord = zSize-1;\r\n        maxSpectralCoord = 0;\r\n        loopSize = zSize;\r\n        spectralComponent = 'z';\r\n        break;\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"POS_Z_DIR\"]:\r\n        minSpectralCoord = xSize-1;\r\n        maxSpectralCoord = 0;\r\n        loopSize = xSize;\r\n        spectralComponent = 'x';\r\n        break;\r\n      case _AudioSceneDefaultConfigs__WEBPACK_IMPORTED_MODULE_2__[\"NEG_Z_DIR\"]:\r\n      default:\r\n        minSpectralCoord = 0;\r\n        maxSpectralCoord = xSize-1;\r\n        loopSize = xSize;\r\n        spectralComponent = 'x';\r\n        break;\r\n    }\r\n\r\n    let numFreqs = Math.floor(fft.length/(gamma+1.8));\r\n\r\n    const spectralLightCoord = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].lerp(minSpectralCoord, maxSpectralCoord, Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(this.avgSpectralCentroid/(numFreqs/2), 0, 1));\r\n\r\n    this.spectralPtLight.position[spectralComponent] = (this.spectralPtLight.position[spectralComponent] + spectralLightCoord) / 2.0;\r\n    const colourRMS = (this.spectralPtLight.colour.r + Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(denoisedRMS*2, 0, 0.333)) / 2.0; // NOTE: rms is typically pretty small (usually less than 0.2)\r\n    this.spectralPtLight.colour.setRGB(colourRMS, colourRMS, colourRMS);\r\n    this.spectralPtLight.attenuation.quadratic = (this.spectralPtLight.attenuation.quadratic + 1.0 / (Math.max(0.01, ptLightDistFromFront*ptLightDistFromFront*10*denoisedRMS))) / 2.0;\r\n    this.spectralPtLight.makeDirty();\r\n\r\n    // Build a distribution of what bins (i.e., meshes) to throw each frequency in\r\n    if (!this.binIndexLookup || numFreqs !== this.binIndexLookup.length) {\r\n      this.binIndexLookup = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_8__[\"default\"].buildBinIndexLookup(numFreqs, loopSize, gamma);\r\n    }\r\n\r\n    // Create the next audio frame from the FFT data\r\n    const newAudioFrame = new Array(loopSize);\r\n    for (let i = 0; i < loopSize; i++) {\r\n      const fftIndices = this.binIndexLookup[i];\r\n      newAudioFrame[i] = _AudioVisUtils__WEBPACK_IMPORTED_MODULE_8__[\"default\"].calcFFTBinLevelMax(fftIndices, fft);\r\n    }\r\n\r\n    const fadeFactorAdjusted = Math.pow(fadeFactor, dt);\r\n    const tempoBeat = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].smootherstep(this.avgBeatsPerSec, 0, 80), 0, 1)*tempoMultiplier;\r\n\r\n    const oneOverSpeed = 1.0 / Math.max(1, speed + tempoBeat);\r\n\r\n    if (this.timeCounter >= oneOverSpeed) {\r\n      const numFrames = Math.min(this.audioFrameBuffer.length, Math.floor(this.timeCounter/oneOverSpeed));\r\n      for (let i = 0; i < numFrames; i++) {\r\n        this.audioFrameBuffer.pop();\r\n        this.audioFrameBuffer.unshift(newAudioFrame);\r\n      }\r\n\r\n      this.timeCounter -= numFrames * oneOverSpeed;\r\n    }\r\n    else {\r\n      for (let i = 0; i < loopSize; i++) {\r\n        const fftIndices = this.binIndexLookup[i];\r\n        this.audioFrameBuffer[0][i] = (_AudioVisUtils__WEBPACK_IMPORTED_MODULE_8__[\"default\"].calcFFTBinLevelMax(fftIndices, fft) + this.audioFrameBuffer[0][i])/2;\r\n      }\r\n      this.timeCounter += dt;\r\n    }\r\n\r\n    // Now update the voxel grid based on all the buffer's current audio frames\r\n    for (let i = 0; i < this.audioFrameBuffer.length; i++) {\r\n      const audioFrame = this.audioFrameBuffer[i];\r\n      let meshIdx = i*loopSize;\r\n      for (let j = 0; j < loopSize; j++) {\r\n        const levelMeshes = this.meshes[meshIdx];\r\n        const binLevel = audioFrame[j];\r\n        this._updateMeshLevels(binLevel, levelMax, fadeFactorAdjusted, levelMeshes);\r\n        meshIdx++;\r\n      }\r\n    }\r\n  }\r\n\r\n  _updateMeshLevels(binLevel, levelMax, fadeFactorAdjusted, levelMeshes) {\r\n    const updateLevel = (cutoffLvl, lvlMeshes) => {\r\n      for (let k = 0; k < lvlMeshes.length; k++) {\r\n        const alpha = k < cutoffLvl ? 1 : 0;\r\n        const mesh = lvlMeshes[k];\r\n        const {material} = mesh;\r\n        material.alpha = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(material.alpha * fadeFactorAdjusted + alpha * (1.0 - fadeFactorAdjusted), 0, 1);\r\n        mesh.setMaterial(material);\r\n      }\r\n    };\r\n\r\n    const cutoffLevel = Math.floor(Object(_MathUtils__WEBPACK_IMPORTED_MODULE_7__[\"clamp\"])(Math.log10(binLevel)/levelMax,0,1) * (levelMeshes.length));\r\n    updateLevel(cutoffLevel, levelMeshes);\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (HistoryBarsAudioVisScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/Audio/HistoryBarsAudioVisScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/FogScene.js":
/*!********************************************!*\
  !*** ./src/VoxelTracer/Scenes/FogScene.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _SceneRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SceneRenderer */ \"./src/VoxelTracer/Scenes/SceneRenderer.js\");\n/* harmony import */ var _VTPointLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VTPointLight */ \"./src/VoxelTracer/VTPointLight.js\");\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n/* harmony import */ var _VTFog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VTFog */ \"./src/VoxelTracer/VTFog.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass FogScene extends _SceneRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(scene, voxelModel) {\r\n    super(scene, voxelModel);\r\n    this._objectsBuilt = false;\r\n    this.timeCounter = 0;\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this._objectsBuilt = false;\r\n  }\r\n\r\n  build(options) {\r\n\r\n    const fogColour = options.fogColour ? options.fogColour : fogSceneDefaultOptions.fogColour;\r\n    const fogScattering = options.fogScattering ? options.fogScattering : _VTFog__WEBPACK_IMPORTED_MODULE_4__[\"fogDefaultOptions\"].fogScattering;\r\n\r\n    const fogOptions = {\r\n      fogColour: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](fogColour.r, fogColour.g, fogColour.b), \r\n      scattering: fogScattering\r\n    };\r\n\r\n    if (!this._objectsBuilt) {\r\n      const ambientLightColour = options.ambientLightColour ? options.ambientLightColour : fogSceneDefaultOptions.ambientLightColour;\r\n      const pointLightColour = options.pointLightColour ? options.pointLightColour : fogSceneDefaultOptions.pointLightColour;\r\n      const pointLightPosition = options.pointLightPosition ? options.pointLightPosition : fogSceneDefaultOptions.pointLightPosition;\r\n      const pointLightAtten = options.pointLightAtten ? options.pointLightAtten : fogSceneDefaultOptions.pointLightAtten;\r\n\r\n      const size = this.voxelModel.xSize();\r\n\r\n      this.ptLight = new _VTPointLight__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\r\n        new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](pointLightPosition.x, pointLightPosition.y, pointLightPosition.z), \r\n        new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](pointLightColour.r, pointLightColour.g, pointLightColour.b), \r\n        {...pointLightAtten}\r\n      );\r\n\r\n      this.ambientLight = new _VTAmbientLight__WEBPACK_IMPORTED_MODULE_3__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](ambientLightColour.r, ambientLightColour.g, ambientLightColour.b));\r\n      this.fog = new _VTFog__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](size, size, size), fogOptions);\r\n\r\n      this._objectsBuilt = true;\r\n    }\r\n    else {\r\n      this.fog.options = fogOptions;\r\n    }\r\n\r\n    this.scene.addLight(this.ptLight);\r\n    this.scene.addLight(this.ambientLight);\r\n    this.scene.addFog(this.fog);\r\n  }\r\n\r\n  async render(dt) {\r\n    if (!this._objectsBuilt) {\r\n      return;\r\n    }\r\n\r\n    const halfXSize = this.voxelModel.xSize()/2;\r\n    const halfYSize = this.voxelModel.ySize()/2;\r\n    const halfZSize = this.voxelModel.zSize()/2;\r\n    const lightMovementRadius = halfXSize-1;\r\n\r\n    const t = this.timeCounter*Math.PI;\r\n\r\n    this.ptLight.setPosition(this.ptLight.position.set(lightMovementRadius*Math.cos(t) + halfXSize, halfYSize, lightMovementRadius*Math.sin(t) + halfZSize));\r\n\r\n    this.timeCounter += dt;\r\n\r\n    await this.scene.render();\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FogScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/FogScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/SceneDefaultConfigs.js":
/*!*******************************************************!*\
  !*** ./src/VoxelTracer/Scenes/SceneDefaultConfigs.js ***!
  \*******************************************************/
/*! exports provided: simpleSceneDefaultOptions, fogSceneDefaultOptions, shadowSceneDefaultOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"simpleSceneDefaultOptions\", function() { return simpleSceneDefaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fogSceneDefaultOptions\", function() { return fogSceneDefaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shadowSceneDefaultOptions\", function() { return shadowSceneDefaultOptions; });\nconst simpleSceneDefaultOptions = {\r\n  sphereRadius: 2,\r\n  sphereColour: {r:1, g:1, b:1},\r\n\r\n  pointLightsSpd: Math.PI,\r\n  pointLight1Colour: {r:1, g:0, b:0},\r\n  pointLight2Colour: {r:0, g:1, b:0},\r\n  pointLight3Colour: {r:0, g:0, b:1},\r\n  pointLightAtten: {quadratic:0.5, linear:0},\r\n\r\n  ambientLightColour: {r:0.01, g:0.01, b:0.01},\r\n\r\n  textureFilename: '',\r\n\r\n  wallX: true,\r\n  wallY: true,\r\n  wallZ: true,\r\n  wallColour: {r:1, g:1, b:1},\r\n};\r\nconst fogSceneDefaultOptions = {\r\n  fogColour: {r:1, g:1, b:1},\r\n  fogScattering: 0.5,\r\n  ambientLightColour: {r:0.1, g:0.1, b:0.1},\r\n  pointLightColour: {r:1, g:1, b:1},\r\n  pointLightPosition: {x:4, y:0, z:4},\r\n  pointLightAtten: {quadratic:0.3, linear:0},\r\n};\r\nconst shadowSceneDefaultOptions = {\r\n  movingBoxSize: {x: 1.5, y:2, z:1.5},\r\n  movingBoxSpeed: 1.5*Math.PI,\r\n  ambientLightColour: {r:0.1, g:0.1, b:0.1},\r\n  pointLightColour: {r:1, g:1, b:1},\r\n  pointLightPosition: {x:4, y:0, z:4},\r\n  pointLightAtten: {quadratic:0, linear:0},\r\n};\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/SceneDefaultConfigs.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/SceneRenderer.js":
/*!*************************************************!*\
  !*** ./src/VoxelTracer/Scenes/SceneRenderer.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\nclass SceneRenderer {\r\n  constructor(scene, voxelModel) {\r\n    this.scene = scene;\r\n    this.voxelModel = voxelModel;\r\n    this.timeCounter = 0;\r\n  }\r\n  clear() {\r\n    this.scene.dispose();\r\n    this._options = null;\r\n  }\r\n\r\n  build(options) {}\r\n\r\n  rebuild(options) {\r\n    this.clear();\r\n    this.build(options);\r\n    this._options = options;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SceneRenderer);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/SceneRenderer.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/ShadowScene.js":
/*!***********************************************!*\
  !*** ./src/VoxelTracer/Scenes/ShadowScene.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _SceneRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SceneRenderer */ \"./src/VoxelTracer/Scenes/SceneRenderer.js\");\n/* harmony import */ var _VTMesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VTMesh */ \"./src/VoxelTracer/VTMesh.js\");\n/* harmony import */ var _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VTLambertMaterial */ \"./src/VoxelTracer/VTLambertMaterial.js\");\n/* harmony import */ var _VTPointLight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VTPointLight */ \"./src/VoxelTracer/VTPointLight.js\");\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ShadowScene extends _SceneRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(scene, voxelModel) {\r\n    super(scene, voxelModel);\r\n    this._objectsBuilt = false;\r\n    this.timeCounter = 0;\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this._objectsBuilt = false;\r\n    \r\n  }\r\n\r\n  build(options) {\r\n    if (!this._objectsBuilt) {\r\n\r\n      const movingBoxSize = options.movingBoxSize ? options.movingBoxSize : shadowSceneDefaultOptions.movingBoxSize;\r\n      const ambientLightColour = options.ambientLightColour ? options.ambientLightColour : shadowSceneDefaultOptions.ambientLightColour;\r\n      const pointLightColour = options.pointLightColour ? options.pointLightColour : shadowSceneDefaultOptions.pointLightColour;\r\n      const pointLightPosition = options.pointLightPosition ? options.pointLightPosition : shadowSceneDefaultOptions.pointLightPosition;\r\n      const pointLightAtten = options.pointLightAtten ? options.pointLightAtten : shadowSceneDefaultOptions.pointLightAtten;\r\n\r\n      const size = this.voxelModel.xSize();\r\n      const halfXSize = this.voxelModel.xSize()/2;\r\n      const halfZSize = this.voxelModel.zSize()/2;\r\n\r\n      this.movingBoxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxBufferGeometry\"](movingBoxSize.x, movingBoxSize.y, movingBoxSize.z, 1, 1, 1);\r\n      this.movingBoxMesh = new _VTMesh__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.movingBoxGeometry, new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_3__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1)));\r\n\r\n      this.boxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxBufferGeometry\"](size,2,size);\r\n      this.boxMesh = new _VTMesh__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.boxGeometry, new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_3__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1)));\r\n      this.boxMesh.setPosition(halfXSize, size-1, halfZSize);\r\n\r\n      this.ptLight = new _VTPointLight__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\r\n        new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](pointLightPosition.x, pointLightPosition.y, pointLightPosition.z), \r\n        new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](pointLightColour.r, pointLightColour.g, pointLightColour.b), \r\n        {...pointLightAtten}\r\n      );\r\n\r\n      this.ambientLight = new _VTAmbientLight__WEBPACK_IMPORTED_MODULE_5__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](ambientLightColour.r, ambientLightColour.g, ambientLightColour.b));\r\n\r\n      this._objectsBuilt = true;\r\n    }\r\n\r\n    this.scene.addLight(this.ptLight);\r\n    this.scene.addObject(this.movingBoxMesh);\r\n    this.scene.addObject(this.boxMesh);\r\n    this.scene.addLight(this.ambientLight);\r\n  }\r\n\r\n  async render(dt) {\r\n    if (!this._objectsBuilt) {\r\n      return;\r\n    }\r\n\r\n    const movingBoxSpeed = this._options.movingBoxSpeed ? this._options.movingBoxSpeed : shadowSceneDefaultOptions.movingBoxSpeed;\r\n\r\n    const halfXSize = this.voxelModel.xSize()/2;\r\n    const halfYSize = this.voxelModel.ySize()/2;\r\n    const halfZSize = this.voxelModel.zSize()/2;\r\n    const RADIUS = halfXSize-1.5;\r\n    const t = this.timeCounter*movingBoxSpeed;\r\n    this.movingBoxMesh.setPosition((RADIUS)*Math.cos(t) + halfXSize, halfYSize-1, (RADIUS)*Math.sin(t) + halfZSize);\r\n    this.timeCounter += dt;\r\n\r\n    await this.scene.render();\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShadowScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/ShadowScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/Scenes/SimpleScene.js":
/*!***********************************************!*\
  !*** ./src/VoxelTracer/Scenes/SimpleScene.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _SceneRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SceneRenderer */ \"./src/VoxelTracer/Scenes/SceneRenderer.js\");\n/* harmony import */ var _VTMesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VTMesh */ \"./src/VoxelTracer/VTMesh.js\");\n/* harmony import */ var _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VTLambertMaterial */ \"./src/VoxelTracer/VTLambertMaterial.js\");\n/* harmony import */ var _VTPointLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VTPointLight */ \"./src/VoxelTracer/VTPointLight.js\");\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n/* harmony import */ var _VTTexture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VTTexture */ \"./src/VoxelTracer/VTTexture.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SimpleScene extends _SceneRenderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n  constructor(scene, voxelModel) {\r\n    super(scene, voxelModel);\r\n    this._objectsBuilt = false;\r\n    this.prevTextureFilename = \"\";\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this._objectsBuilt = false;\r\n  }\r\n\r\n  build(options) {\r\n    const {wallX, wallY, wallZ} = options;\r\n\r\n    if (!this._objectsBuilt) {\r\n      const {\r\n        sphereRadius, sphereColour,\r\n        ambientLightColour, \r\n        pointLight1Colour, pointLight2Colour, pointLight3Colour, pointLightAtten, \r\n        textureFilename,\r\n        wallColour,\r\n      } = options;\r\n\r\n      if (textureFilename.length > 0) {\r\n        let textureFilepath = \"dist/textures/\" + textureFilename;\r\n        if (textureFilepath !== this.prevTextureFilename) {\r\n          this.sphereTexture = null;\r\n          if (fs__WEBPACK_IMPORTED_MODULE_1___default.a.existsSync(textureFilepath)) {\r\n            this.sphereTexture = new _VTTexture__WEBPACK_IMPORTED_MODULE_7__[\"default\"](textureFileToUse);\r\n            this.prevTextureFilename = textureFileToUse;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        this.sphereTexture = null;\r\n      }\r\n\r\n      this.sphereGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereBufferGeometry\"](sphereRadius, 20, 20);\r\n      this.sphereMesh = new _VTMesh__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.sphereGeometry, new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](sphereColour.r, sphereColour.g, sphereColour.b), 1, this.sphereTexture || null));\r\n      this.sphereMesh.setPosition(this.voxelModel.xSize()/2, this.voxelModel.ySize()/2, this.voxelModel.zSize()/2);\r\n\r\n      this.ptLight1 = new _VTPointLight__WEBPACK_IMPORTED_MODULE_5__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](pointLight1Colour.r, pointLight1Colour.g, pointLight1Colour.b), {...pointLightAtten});\r\n      this.ptLight2 = new _VTPointLight__WEBPACK_IMPORTED_MODULE_5__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](pointLight2Colour.r, pointLight2Colour.g, pointLight2Colour.b), {...pointLightAtten});\r\n      this.ptLight3 = new _VTPointLight__WEBPACK_IMPORTED_MODULE_5__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](pointLight3Colour.r, pointLight3Colour.g, pointLight3Colour.b), {...pointLightAtten});\r\n      this.ambientLight = new _VTAmbientLight__WEBPACK_IMPORTED_MODULE_6__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](ambientLightColour.r, ambientLightColour.g, ambientLightColour.b));\r\n\r\n      const size = this.voxelModel.xSize();\r\n      const halfXSize = this.voxelModel.xSize()/2;\r\n      const halfYSize = this.voxelModel.ySize()/2;\r\n      const halfZSize = this.voxelModel.zSize()/2;\r\n  \r\n      if (wallX) {\r\n        this.wallXGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxBufferGeometry\"](1,size,size);\r\n        this.wallXMesh = new _VTMesh__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.wallXGeometry, new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](wallColour.r, wallColour.g, wallColour.b)));\r\n        this.wallXMesh.setPosition(0, halfYSize, halfZSize);\r\n      }\r\n      if (wallY) {\r\n        this.wallYGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxBufferGeometry\"](size,1,size);\r\n        this.wallYMesh = new _VTMesh__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.wallYGeometry, new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](wallColour.r, wallColour.g, wallColour.b)));\r\n        this.wallYMesh.setPosition(halfXSize, 0, halfZSize);\r\n      }\r\n      if (wallZ) {\r\n        this.wallZGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxBufferGeometry\"](size,size,1);\r\n        this.wallZMesh = new _VTMesh__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.wallZGeometry, new _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](wallColour.r, wallColour.g, wallColour.b)));\r\n        this.wallZMesh.setPosition(halfXSize, halfYSize, 0);\r\n      }\r\n\r\n      this._objectsBuilt = true;\r\n    }\r\n\r\n    this.scene.addLight(this.ptLight1);\r\n    this.scene.addLight(this.ptLight2);\r\n    this.scene.addLight(this.ptLight3);\r\n    this.scene.addLight(this.ambientLight);\r\n    this.scene.addObject(this.sphereMesh);\r\n\r\n    if (wallX) {\r\n      this.scene.addObject(this.wallXMesh);\r\n    }\r\n    if (wallY) {\r\n      this.scene.addObject(this.wallYMesh);\r\n    }\r\n    if (wallZ) {\r\n      this.scene.addObject(this.wallZMesh);\r\n    }\r\n  }\r\n\r\n  async render(dt) {\r\n    if (!this._objectsBuilt) {\r\n      return;\r\n    }\r\n\r\n    const {pointLightsSpd, sphereRadius} = this._options;\r\n\r\n    // Move lights around in circles...\r\n    const halfXSize = this.voxelModel.xSize()/2;\r\n    const halfYSize = this.voxelModel.ySize()/2;\r\n    const halfZSize = this.voxelModel.zSize()/2;\r\n    const lightMovementRadius = sphereRadius + 1;\r\n\r\n    const t = this.timeCounter*pointLightsSpd;\r\n\r\n    this.ptLight1.setPosition(this.ptLight1.position.set(lightMovementRadius*Math.cos(t) + halfXSize, halfYSize, lightMovementRadius*Math.sin(t) + halfZSize));\r\n    this.ptLight2.setPosition(this.ptLight2.position.set(halfXSize, lightMovementRadius*Math.cos(t) + halfYSize, lightMovementRadius*Math.sin(t) + halfZSize));\r\n    this.ptLight3.setPosition(this.ptLight3.position.set(lightMovementRadius*Math.sin(t) + halfXSize, lightMovementRadius*Math.cos(t) + halfYSize, halfZSize));\r\n    \r\n    this.timeCounter += dt;\r\n\r\n    await this.scene.render();\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SimpleScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/Scenes/SimpleScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTAmbientLight.js":
/*!*******************************************!*\
  !*** ./src/VoxelTracer/VTAmbientLight.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n\r\n\r\n\r\n\r\nclass VTAmbientLight extends _VTRenderable__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(colour=new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0)) {\r\n    super(_VTRenderable__WEBPACK_IMPORTED_MODULE_1__[\"default\"].AMBIENT_LIGHT_TYPE);\r\n    this._colour = colour instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"] ? colour : new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colour.r, colour.g, colour.b);\r\n    this.makeDirty();\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {id, _colour} = jsonData;\r\n    const colour = (new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]()).setHex(_colour);\r\n    const result = new VTAmbientLight(colour);\r\n    result.id = id;\r\n    return result;\r\n  }\r\n\r\n  get colour() { return this._colour; }\r\n  setColour(c) {this._colour = c; this.makeDirty(); }\r\n\r\n  makeDirty() { this._isDirty = true; }\r\n\r\n  isDirty() { return this._isDirty; }\r\n\r\n  unDirty(scene=null) {\r\n    if (this._isDirty) {\r\n      this._isDirty = false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  toJSON() {\r\n    const {id, type, _colour} = this;\r\n    return {id, type, _colour};\r\n  }\r\n\r\n  dispose() {}\r\n\r\n  emission() {\r\n    return this._colour.clone();\r\n  }\r\n\r\n  getCollidingVoxels(voxelGridBoundingBox=null) {\r\n    return [];\r\n  }\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTAmbientLight);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTAmbientLight.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTConstants.js":
/*!****************************************!*\
  !*** ./src/VoxelTracer/VTConstants.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\n\r\nclass VTConstants {\r\n  static get INVALID_RENDERABLE_ID() { return -1; }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTConstants);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTConstants.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTEmissionMaterial.js":
/*!***********************************************!*\
  !*** ./src/VoxelTracer/VTEmissionMaterial.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VTMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTMaterial */ \"./src/VoxelTracer/VTMaterial.js\");\n/* harmony import */ var _VTTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTTexture */ \"./src/VoxelTracer/VTTexture.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass VTEmissionMaterial extends _VTMaterial__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(colour, alpha=1, texture=null) {\r\n    super(_VTMaterial__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EMISSION_TYPE);\r\n    this.colour = colour instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"] ? colour : new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colour.r, colour.g, colour.b);\r\n    this.alpha = alpha;\r\n    this.texture = texture;\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {colour, alpha, texture} = jsonData;\r\n    const threeColour = (new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]()).setHex(colour);\r\n    return new VTEmissionMaterial(threeColour, alpha, _VTTexture__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build(texture));\r\n  }\r\n\r\n  dispose() {}\r\n\r\n  toJSON() {\r\n    const {type, colour, alpha, texture} = this;\r\n    return {type, colour, alpha, texture};\r\n  }\r\n\r\n  emission(uv) {\r\n    return this.albedo(uv);\r\n  }\r\n\r\n  isVisible() {\r\n    return Math.round(this.alpha*255) >= 1;\r\n  }\r\n\r\n  albedo(uv) {\r\n    const albedoColour = this.colour.clone();\r\n    if (uv && this.texture && this.texture.isLoaded()) {\r\n      albedoColour.multiply(this.texture.sample(uv));\r\n    }\r\n    return albedoColour;\r\n  }\r\n\r\n  brdf(nObjToLightVec, normal, uv, lightColour) {\r\n    const dot = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(nObjToLightVec.dot(normal), 0, 1);\r\n    return this.brdfAmbient(uv, lightColour).multiplyScalar(dot);\r\n  }\r\n\r\n  brdfAmbient(uv, lightColour) {\r\n    const albedoColour = this.albedo(uv);\r\n    albedoColour.add(lightColour).multiplyScalar(this.alpha);\r\n    return albedoColour;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTEmissionMaterial);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTEmissionMaterial.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTFog.js":
/*!**********************************!*\
  !*** ./src/VoxelTracer/VTFog.js ***!
  \**********************************/
/*! exports provided: fogDefaultOptions, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fogDefaultOptions\", function() { return fogDefaultOptions; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst fogDefaultOptions = {\r\n  scattering: 0.1, // The amount of light reduction per voxel travelled through of the fog this must be in [0,1]\r\n  fogColour: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1,1,1),\r\n};\r\n\r\nclass VTFog extends _VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n  constructor(minPt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](2,2,2), maxPt=new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](5,5,5), options={...fogDefaultOptions}) {\r\n    super(_VTRenderable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].FOG_TYPE);\r\n\r\n    this._boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"](minPt, maxPt);\r\n    this._colour = options.fogColour ? options.fogColour : fogDefaultOptions.fogColour;\r\n    this._scattering = options.scattering ? options.scattering : fogDefaultOptions.scattering;\r\n\r\n    // Temporary objects\r\n    this._temp1Vec3 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n    this._temp2Vec3 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n    this.makeDirty();\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {id, _colour, _boundingBox, _scattering} = jsonData;\r\n    const colour = (new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]()).setHex(_colour);\r\n    const {min, max} = _boundingBox;\r\n    const minPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](min.x, min.y, min.z);\r\n    const maxPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](max.x, max.y, max.z);\r\n    const result = new VTFog(minPt, maxPt, {fogColour: colour, scattering: _scattering});\r\n    result.id = id;\r\n    return result;\r\n  }\r\n\r\n  setBoundingBox(b) { this._boundingBox = b; this.makeDirty(); }\r\n  setColour(c) { this._colour = c; this.makeDirty(); }\r\n  setScattering(s) {this._scattering = s; this.makeDirty(); }\r\n\r\n  dispose() {}\r\n\r\n  makeDirty() { this._isDirty = true; }\r\n\r\n  isDirty() { return this._isDirty; }\r\n\r\n  unDirty(scene=null) {\r\n    if (this._isDirty) {\r\n      this._isDirty = false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  isShadowCaster() { return true; }\r\n\r\n  toJSON() {\r\n    const {id, type, _colour, _boundingBox, _scattering} = this;\r\n    return {id, type, _colour, _boundingBox, _scattering};\r\n  }\r\n\r\n  position(target) { \r\n    return this._boundingBox.getCenter(target); \r\n  }\r\n  setPosition(pos) {\r\n    const size = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n    this._boundingBox.getSize(size);\r\n    this._boundingBox.setFromCenterAndSize(pos, size);\r\n  }\r\n\r\n  calculateShadow(raycaster) {\r\n    const result = {\r\n      inShadow: false,\r\n      lightReduction: 0,\r\n    };\r\n\r\n    const {ray} = raycaster;\r\n\r\n    // First check to see if the ray originates inside this fog\r\n    if (this._boundingBox.containsPoint(ray.origin)) {\r\n      // The first point is the origin of the ray\r\n      this._temp1Vec3.copy(ray.origin);\r\n      // The second point is where the ray intersects the bounding box of the fog\r\n      result.inShadow = (ray.intersectBox(this._boundingBox, this._temp2Vec3) !== null);\r\n    }\r\n    else {\r\n      // Calculate the distance the ray travels through this fog (if at all)\r\n      const intersect1Result = ray.intersectBox(this._boundingBox, this._temp1Vec3);\r\n      if (intersect1Result !== null) {\r\n        // Find the next intersection point on the fog box using a ray whose origin is just offset \r\n        // from the inside of the box near the first collision point \r\n        const insideBoxRay = ray.clone();\r\n        insideBoxRay.origin.set(this._temp1Vec3.x, this._temp1Vec3.y, this._temp1Vec3.z);\r\n        insideBoxRay.origin.add(insideBoxRay.direction.clone().multiplyScalar(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"VOXEL_EPSILON\"]));\r\n        result.inShadow = (insideBoxRay.intersectBox(this._boundingBox, this._temp2Vec3) !== null);\r\n      }\r\n    }\r\n\r\n    if (result.inShadow) {\r\n      // Calculate the distance the light has travelled, use it to modulate the transimission through the fog\r\n      result.lightReduction = this._scattering * this._temp1Vec3.sub(this._temp2Vec3).length();\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  calculateVoxelColour(voxelIdxPt, scene) {\r\n    const finalColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n    if (this._boundingBox.containsPoint(voxelIdxPt)) {\r\n      // Fog captures light in the scene...\r\n      const fogLighting = scene.calculateFogLighting(voxelIdxPt);\r\n      finalColour.setRGB(\r\n        Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(this._scattering*(fogLighting.r * this._colour.r), 0, 1), \r\n        Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(this._scattering*(fogLighting.g * this._colour.g), 0, 1), \r\n        Object(_MathUtils__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(this._scattering*(fogLighting.b * this._colour.b), 0, 1)\r\n      );\r\n      \r\n    }\r\n\r\n    return finalColour;\r\n  }\r\n\r\n  intersectsBox(box) {\r\n    return this._boundingBox.intersectsBox(box);\r\n  }\r\n\r\n  getCollidingVoxels(voxelGridBoundingBox) {\r\n    return _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_2__[\"default\"].voxelBoxList(this._boundingBox.min, this._boundingBox.max, true, voxelGridBoundingBox);\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTFog);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTFog.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTLambertMaterial.js":
/*!**********************************************!*\
  !*** ./src/VoxelTracer/VTLambertMaterial.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VTMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTMaterial */ \"./src/VoxelTracer/VTMaterial.js\");\n/* harmony import */ var _VTTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTTexture */ \"./src/VoxelTracer/VTTexture.js\");\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass VTLambertMaterial extends _VTMaterial__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(colour, alpha=1, texture=null, reflect=false) {\r\n    super(_VTMaterial__WEBPACK_IMPORTED_MODULE_1__[\"default\"].LAMBERT_TYPE);\r\n    this.colour = colour instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"] ? colour : new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colour.r, colour.g, colour.b);\r\n    this.alpha = alpha;\r\n    this.texture = texture;\r\n    this.reflect = reflect;\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {colour, alpha, texture, reflect} = jsonData;\r\n    const threeColour = (new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]()).setHex(colour);\r\n    return new VTLambertMaterial(threeColour, alpha, _VTTexture__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build(texture), reflect);\r\n  }\r\n\r\n  dispose() {}\r\n\r\n  toJSON() {\r\n    const {type, colour, alpha, texture, reflect} = this;\r\n    return {type, colour, alpha, texture, reflect};\r\n  }\r\n\r\n  isVisible() {\r\n    return Math.round(this.alpha*255) >= 1;\r\n  }\r\n\r\n  emission(uv) {\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n  }\r\n\r\n  albedo(uv) {\r\n    const albedoColour = this.colour.clone();\r\n    if (uv && this.texture && this.texture.isLoaded()) {\r\n      albedoColour.multiply(this.texture.sample(uv));\r\n    }\r\n    return albedoColour;\r\n  }\r\n\r\n  brdf(nObjToLightVec, normal, uv, lightColour) {\r\n    const dot = Object(_MathUtils__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(nObjToLightVec.dot(normal), 0, 1);\r\n    return this.brdfAmbient(uv, lightColour).multiplyScalar(dot);\r\n  }\r\n\r\n  brdfAmbient(uv, lightColour) {\r\n    return this.reflect ? this._reflectiveBrdfAmbient(uv, lightColour) : this.basicBrdfAmbient(uv, lightColour);\r\n  }\r\n\r\n  basicBrdfAmbient(uv, lightColour) {\r\n    const albedoColour = this.albedo(uv);\r\n    albedoColour.multiply(lightColour).multiplyScalar(this.alpha);\r\n    return albedoColour;\r\n  }\r\n  _reflectiveBrdfAmbient(uv, lightColour) {\r\n    const albedoColour = this.albedo(uv);\r\n    albedoColour.add(lightColour).multiply(lightColour).multiplyScalar(this.alpha);\r\n    return albedoColour;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTLambertMaterial);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTLambertMaterial.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTMaterial.js":
/*!***************************************!*\
  !*** ./src/VoxelTracer/VTMaterial.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\nclass VTMaterial {\r\n  static get LAMBERT_TYPE()  { return 'l'; }\r\n  static get EMISSION_TYPE() { return 'e'; }\r\n\r\n  constructor(type) {\r\n    this.type = type;\r\n  }\r\n\r\n  isVisible() { console.error(\"isVisible unimplemented abstract method called.\"); return true; }\r\n  albedo(uv) { console.error(\"albedo unimplemented abstract method called.\");  return null; }\r\n  brdf(nObjToLightVec, normal, uv, lightColour) { console.error(\"brdf unimplemented abstract method called.\");  return null; }\r\n  brdfAmbient(uv, lightColour) { console.error(\"brdfAmbient unimplemented abstract method called.\");  return null; }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTMaterial);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTMaterial.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTMaterialFactory.js":
/*!**********************************************!*\
  !*** ./src/VoxelTracer/VTMaterialFactory.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTMaterial */ \"./src/VoxelTracer/VTMaterial.js\");\n/* harmony import */ var _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTLambertMaterial */ \"./src/VoxelTracer/VTLambertMaterial.js\");\n/* harmony import */ var _VTEmissionMaterial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTEmissionMaterial */ \"./src/VoxelTracer/VTEmissionMaterial.js\");\n\r\n\r\n\r\n\r\n\r\nclass VTMaterialFactory {\r\n  static build(jsonData) {\r\n    const {type} = jsonData;\r\n    let result = null;\r\n\r\n    // TODO: Have texture ids to avoid massive duplications here...\r\n\r\n    switch (type) {\r\n      case _VTMaterial__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LAMBERT_TYPE: {\r\n        result = _VTLambertMaterial__WEBPACK_IMPORTED_MODULE_1__[\"default\"].build(jsonData);\r\n        break;\r\n      }\r\n      case _VTMaterial__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EMISSION_TYPE: {\r\n        result = _VTEmissionMaterial__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build(jsonData);\r\n        break;\r\n      }\r\n      default:\r\n        console.error(`Invalid material type: ${type}, found in jsonData: ${jsonData}`);\r\n        break;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTMaterialFactory);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTMaterialFactory.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTMesh.js":
/*!***********************************!*\
  !*** ./src/VoxelTracer/VTMesh.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three-mesh-bvh */ \"three-mesh-bvh\");\n/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _MathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MathUtils */ \"./src/MathUtils.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n/* harmony import */ var _VTMaterialFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VTMaterialFactory */ \"./src/VoxelTracer/VTMaterialFactory.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Add the extension functions for calculating bounding volumes for THREE.Mesh/THREE.Geometry\r\nthree__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"].prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"computeBoundsTree\"];\r\nthree__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"].prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"disposeBoundsTree\"];\r\nthree__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"].prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"acceleratedRaycast\"];\r\n\r\n\r\nclass VTTriSample {\r\n  constructor(wsTri, indices, sqrDist, wsClosestPt) {\r\n    this.triangle = wsTri;\r\n    this.indices = indices;\r\n    this.sqrDist = sqrDist;\r\n    this.worldSpaceClosestPt = wsClosestPt;\r\n    this.sample = {\r\n      point: wsClosestPt,\r\n      normal: new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\r\n      uv: new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\r\n      falloff: 1,\r\n    };\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {triangle, indices, sqrDist, worldSpaceClosestPt, sample} = jsonData;\r\n    const result = new VTTriSample(triangle, indices, sqrDist, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](worldSpaceClosestPt.x, worldSpaceClosestPt.y, worldSpaceClosestPt.z));\r\n\r\n    const {normal, uv, falloff} = sample;\r\n    result.sample.normal.set(normal.x, normal.y, normal.z);\r\n    result.sample.uv.set(uv.x, uv.y);\r\n    result.sample.falloff = falloff;\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nclass VTMesh extends _VTRenderable__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\r\n  // NOTE: All geometry MUST be buffer geometry!\r\n  constructor(geometry, material) {\r\n    super(_VTRenderable__WEBPACK_IMPORTED_MODULE_4__[\"default\"].MESH_TYPE);\r\n    \r\n    if (geometry) {\r\n      this.geometry = geometry;\r\n      this.geometry.computeBoundingBox();\r\n      this.geometry.boundsTree = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"MeshBVH\"](this.geometry, {strategy: three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"SAH\"]});\r\n      this.threeMesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](this.geometry);\r\n    }\r\n    this.material = material;\r\n\r\n    // Temporary variables for use when calculating cached/memoized samples\r\n    this._closestPt     = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    this._voxelCenterPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    this._baryCoord     = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    this._n0  = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    this._n1  = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    this._n2  = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,0);\r\n    this._uv0 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](0,0);\r\n    this._uv1 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](0,0);\r\n    this._uv2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](0,0);\r\n    this._tempVec3 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n\r\n    // Memoization for voxel collisions and sampling\r\n    this.voxelIdxToTriSamples = {};\r\n    this.makeDirty();\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {id, threeMesh, material} = jsonData;\r\n\r\n    const result = new VTMesh(null, _VTMaterialFactory__WEBPACK_IMPORTED_MODULE_5__[\"default\"].build(material));\r\n    result.id = id;\r\n    \r\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__[\"ObjectLoader\"]();\r\n    const loadedMesh = loader.parse(threeMesh);\r\n    loadedMesh.geometry.computeBoundingBox();\r\n    loadedMesh.geometry.boundsTree = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"MeshBVH\"](loadedMesh.geometry, {strategy: three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__[\"SAH\"]});\r\n    loadedMesh.updateMatrixWorld();\r\n    \r\n    result.geometry = loadedMesh.geometry;\r\n    result.threeMesh = loadedMesh;\r\n    \r\n    return result;\r\n  }\r\n  toJSON() {\r\n    const {id, type, threeMesh, material} = this;\r\n    return {id, type, threeMesh, material};\r\n  }\r\n\r\n  dispose() {\r\n    this.geometry.disposeBoundsTree();\r\n    this.geometry.dispose();\r\n    this.material.dispose();\r\n    this.makeDirty();\r\n  }\r\n\r\n  isDirty() {\r\n    return this._isDirty;\r\n  }\r\n  makeDirty() {\r\n    this._isDirty = true;\r\n  }\r\n  unDirty(scene) {\r\n    if (this._isDirty) {\r\n      this.updateMatrixWorld();\r\n      this.voxelIdxToTriSamples = {};\r\n      this._isDirty = false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  isShadowCaster() { return true; }\r\n\r\n  // Transform methods\r\n  setPosition(x,y,z) { \r\n    this.threeMesh.position.set(x,y,z);\r\n    this.makeDirty();\r\n  }\r\n  updateMatrixWorld() { this.threeMesh.updateMatrixWorld(); }\r\n\r\n  calculateShadow(raycaster) {\r\n    return {\r\n      inShadow: this.intersectsRay(raycaster),\r\n      lightReduction: 1.0, // [0,1]: 1 => Completely black out the light if a voxel is in shadow from this object\r\n    };\r\n  }\r\n\r\n  _preRender(voxelIdxPt, voxelId) {\r\n    let vtTriSamples = null;\r\n\r\n    // Have we memoized the current voxel index point yet?\r\n    if (voxelId in this.voxelIdxToTriSamples) {\r\n      // Just use the memoized values...\r\n      vtTriSamples = this.voxelIdxToTriSamples[voxelId];\r\n    }\r\n    else if (this.threeMesh.geometry.boundsTree) {\r\n      // We need to build a set of new triangle samples for the given voxel\r\n      const voxelBoundingBox = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_3__[\"default\"].calcVoxelBoundingBox(voxelIdxPt);\r\n      voxelBoundingBox.getCenter(this._voxelCenterPt);\r\n  \r\n      const furthestPossibleDistFromCenter = _MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"SQRT3\"]*Math.SQRT1_2;\r\n  \r\n      // Start by finding all triangles in this mesh that may intersect with the given voxel\r\n      vtTriSamples = [];\r\n      this.threeMesh.geometry.boundsTree.shapecast(\r\n        this.threeMesh,\r\n        box => {\r\n          const worldSpaceBox = box.clone();\r\n          worldSpaceBox.applyMatrix4(this.threeMesh.matrixWorld);\r\n          return voxelBoundingBox.intersectsBox(worldSpaceBox);\r\n        },\r\n        (tri, a, b, c) => {\r\n          const {matrixWorld} = this.threeMesh;\r\n          const worldSpaceTri = tri.clone();\r\n          worldSpaceTri.a.applyMatrix4(matrixWorld);\r\n          worldSpaceTri.b.applyMatrix4(matrixWorld);\r\n          worldSpaceTri.c.applyMatrix4(matrixWorld);\r\n  \r\n          worldSpaceTri.closestPointToPoint(this._voxelCenterPt, this._closestPt);\r\n  \r\n          // Is the closest point even inside the voxel?\r\n          if (voxelBoundingBox.containsPoint(this._closestPt)) {\r\n            this._tempVec3.copy(this._closestPt);\r\n            const sqrDist = this._tempVec3.sub(this._voxelCenterPt).lengthSq();\r\n  \r\n            vtTriSamples.push(new VTTriSample(worldSpaceTri, [a, b, c], sqrDist, this._closestPt.clone()));\r\n          }\r\n  \r\n          return false; // We return false here to make sure we get the exhaustive list of all intersected triangles\r\n        }\r\n      );\r\n      \r\n      if (vtTriSamples.length > 0) {\r\n        const indexAttr  = this.geometry.index;\r\n        const normalAttr = this.geometry.getAttribute('normal');\r\n        const uvAttr     = this.geometry.getAttribute('uv');\r\n  \r\n        const calculateNormalBarycentric = (target, i0, i1, i2, baryCoord) => {\r\n          this._n0.set(normalAttr.getX(i0), normalAttr.getY(i0), normalAttr.getZ(i0));\r\n          this._n1.set(normalAttr.getX(i1), normalAttr.getY(i1), normalAttr.getZ(i1));\r\n          this._n2.set(normalAttr.getX(i2), normalAttr.getY(i2), normalAttr.getZ(i2));\r\n          this._n0.multiplyScalar(baryCoord.x);\r\n          this._n1.multiplyScalar(baryCoord.y);\r\n          this._n2.multiplyScalar(baryCoord.z);\r\n          this._n0.add(this._n1.add(this._n2));\r\n          this._n0.normalize();\r\n          this._n0.transformDirection(this.threeMesh.matrixWorld);\r\n  \r\n          target.copy(this._n0);\r\n        };\r\n        const calculateUVBarycentric = (target, i0, i1, i2, baryCoord) => {\r\n          this._uv0.set(uvAttr.getX(i0), uvAttr.getY(i0));\r\n          this._uv1.set(uvAttr.getX(i1), uvAttr.getY(i1));\r\n          this._uv2.set(uvAttr.getX(i2), uvAttr.getY(i2));\r\n          this._uv0.multiplyScalar(baryCoord.x);\r\n          this._uv1.multiplyScalar(baryCoord.y);\r\n          this._uv2.multiplyScalar(baryCoord.z);\r\n          this._uv0.add(this._uv1.add(this._uv2));\r\n  \r\n          target.copy(this._uv0);\r\n        };\r\n  \r\n        const sigma = furthestPossibleDistFromCenter / 10.0;\r\n        const valueAtZero = (1.0 / _MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"SQRT2PI\"]*sigma);\r\n  \r\n        for (let i = 0; i < vtTriSamples.length; i++) {\r\n          const vtTri = vtTriSamples[i];\r\n          \r\n          const triangle = vtTri.triangle;\r\n          const worldSpaceClosestPt = vtTri.worldSpaceClosestPt;\r\n          const sqrDist = vtTri.sqrDist;\r\n          const indices = vtTri.indices;\r\n          const sample = vtTri.sample;\r\n  \r\n          triangle.getBarycoord(worldSpaceClosestPt, this._baryCoord);\r\n          const i0 = indexAttr.getX(indices[0]);\r\n          const i1 = indexAttr.getX(indices[1]);\r\n          const i2 = indexAttr.getX(indices[2]);\r\n  \r\n          calculateNormalBarycentric(sample.normal, i0, i1, i2, this._baryCoord);\r\n          calculateUVBarycentric(sample.uv, i0, i1, i2, this._baryCoord);\r\n  \r\n          // Is the voxel sample point (i.e., the center) inside or outside the triangle?\r\n          this._tempVec3.copy(sample.point);\r\n          this._tempVec3.sub(this._voxelCenterPt).normalize();\r\n          const toTriangleDotNorm = this._tempVec3.dot(sample.normal);\r\n  \r\n          // If the dot product was positive then the voxel sample point is \"inside\" the mesh, \r\n          // otherwise it's outside - in this case we use a gaussian falloff to dim the voxel.\r\n          sample.falloff = (toTriangleDotNorm >= 0.0) ? 1.0 : ((1.0 / _MathUtils__WEBPACK_IMPORTED_MODULE_2__[\"SQRT2PI\"]*sigma) * Math.exp(-0.5 * (sqrDist / (2*sigma*sigma))) / valueAtZero);\r\n        }\r\n      }\r\n\r\n      this.voxelIdxToTriSamples[voxelId] = vtTriSamples;\r\n    }\r\n\r\n    return vtTriSamples;\r\n  }\r\n\r\n  calculateVoxelColour(voxelIdxPt, scene) {\r\n    const voxelId = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_3__[\"default\"].voxelFlatIdx(voxelIdxPt, scene.gridSize);\r\n    let finalColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n\r\n    // Fast-out if we can't even see this mesh\r\n    if (!this.material.isVisible()) {\r\n      return finalColour;\r\n    }\r\n    \r\n    // Grab a list of all the samples\r\n    const vtTriSamples = this._preRender(voxelIdxPt, voxelId);\r\n    if (vtTriSamples.length > 0) {\r\n      const samples = vtTriSamples.map(triSample => triSample.sample);\r\n      finalColour.add(scene.calculateLightingSamples(samples, this.material));\r\n    }\r\n    \r\n    return finalColour;\r\n  }\r\n\r\n  intersectsBox(box) {\r\n    return this.geometry.boundsTree.intersectsBox(this.threeMesh, box, new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]());\r\n  }\r\n\r\n  intersectsRay(raycaster) {\r\n    //return this.geometry.boundsTree.raycastFirst(this.threeMesh, raycaster, raycaster.ray) !== null;\r\n    raycaster.firstHitOnly = true;\r\n    return raycaster.intersectObjects([this.threeMesh]).length > 0;\r\n  }\r\n\r\n  getCollidingVoxels(voxelGridBoundingBox) {\r\n    const worldSpaceBB = this.geometry.boundingBox.clone().applyMatrix4(this.threeMesh.matrixWorld);\r\n    return _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_3__[\"default\"].voxelBoxList(worldSpaceBB.min, worldSpaceBB.max, true, voxelGridBoundingBox);\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTMesh);\r\n\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTMesh.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTPointLight.js":
/*!*****************************************!*\
  !*** ./src/VoxelTracer/VTPointLight.js ***!
  \*****************************************/
/*! exports provided: defaultAttenuation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultAttenuation\", function() { return defaultAttenuation; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n\r\n\r\n\r\n\r\nconst defaultAttenuation = {\r\n  quadratic:0, \r\n  linear:1, \r\n};\r\n\r\nclass VTPointLight extends _VTRenderable__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n  constructor(position, colour, attenuation=defaultAttenuation) {\r\n    super(_VTRenderable__WEBPACK_IMPORTED_MODULE_2__[\"default\"].POINT_LIGHT_TYPE);\r\n\r\n    this._position = position;\r\n    this._colour = colour instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"] ? colour : new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](colour.r, colour.g, colour.b);\r\n    this._attenuation = attenuation;\r\n    this._isDirty = true;\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {id, _position, _colour, _attenuation} = jsonData;\r\n    const colour = (new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]()).setHex(_colour);\r\n    const result = new VTPointLight(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](_position.x, _position.y, _position.z), colour, _attenuation);\r\n    result.id = id;\r\n    return result;\r\n  }\r\n\r\n  setPosition(p) { this._position = p; this.makeDirty(); }\r\n  get position() { return this._position; }\r\n\r\n  setColour(c) { this._colour = c; this.makeDirty(); }\r\n  get colour()  { return this._colour; }\r\n\r\n  setAttenuation(a) { this._attenuation = a; this.makeDirty(); }\r\n  get attenuation() { return this._attenuation; }\r\n\r\n  dispose() {}\r\n\r\n  isDirty() { return this._isDirty; }\r\n  makeDirty() { this._isDirty = true; }\r\n  unDirty(scene=null) {\r\n    if (this._isDirty) {\r\n      this._isDirty = false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  isShadowCaster() { return false; }\r\n\r\n  toJSON() {\r\n    const {id, type, _position, _colour, _attenuation} = this;\r\n    return {id, type, _position, _colour, _attenuation};\r\n  }\r\n\r\n  emission(distance) {\r\n    // TODO: This can blow out a colour... maybe map it to a spectrum or something when we want to get fancy?\r\n    const emissionColour = this._colour.clone().multiplyScalar(this.calculateAttenuation(distance));\r\n    emissionColour.setRGB(emissionColour.r, emissionColour.g, emissionColour.b);\r\n    return emissionColour;\r\n  }\r\n\r\n  calculateAttenuation(distance) {\r\n    return 1.0 / (this._attenuation.quadratic*distance*distance + this._attenuation.linear*distance + 1.0); // Always in [0,1]\r\n  }\r\n\r\n  calculateVoxelColour(voxelPt, scene=null) {\r\n    const d = this._position.distanceTo(voxelPt);\r\n    return this.emission(d);\r\n  }\r\n\r\n  intersectsBox(voxelBoundingBox) {\r\n    return this.boundingSphere().intersectsBox(voxelBoundingBox);\r\n  }\r\n\r\n  boundingBox() {\r\n    const minPos = this._position.clone().subScalar(0.5);\r\n    const maxPos = this._position.clone().addScalar(0.5);\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"](minPos, maxPos);\r\n  }\r\n\r\n  boundingSphere() {\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Sphere\"](this._position.clone(), 0.5);\r\n  }\r\n\r\n  getCollidingVoxels(voxelGridBoundingBox=null) {\r\n    // Just return the nearest voxel to this light (since it's a point light it will only be a single voxel)\r\n    return [_Server_VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].closestVoxelIdxPt(this._position)];\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTPointLight);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTPointLight.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTRenderable.js":
/*!*****************************************!*\
  !*** ./src/VoxelTracer/VTRenderable.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTConstants */ \"./src/VoxelTracer/VTConstants.js\");\n\r\n\r\nclass VTRenderable {\r\n  \r\n  static get MESH_TYPE() { return 'm'; }\r\n  static get AMBIENT_LIGHT_TYPE() { return 'a'; }\r\n  static get POINT_LIGHT_TYPE() { return 'p'; }\r\n  static get VOXEL_TYPE() { return 'v'; }\r\n  static get FOG_TYPE() { return 'f'; }\r\n  \r\n  constructor(type) {\r\n    this.id = _VTConstants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INVALID_RENDERABLE_ID;\r\n    this.type = type;\r\n  }\r\n\r\n  dispose() { console.error(\"dispose unimplemented abstract method called.\"); }\r\n  isDirty()  { console.error(\"isDirty unimplemented abstract method called.\"); return false; }\r\n  unDirty(scene=null) { console.error(\"unDirty unimplemented abstract method called.\"); return true; }\r\n  isShadowCaster() { console.error(\"isShadowCaster unimplemented abstract method called.\"); return false; }\r\n  getCollidingVoxels(voxelGridBoundingBox=null) { console.error(\"getCollidingVoxels unimplemented abstract method called.\"); return []; }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTRenderable);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTRenderable.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTScene.js":
/*!************************************!*\
  !*** ./src/VoxelTracer/VTScene.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _VTAmbientLight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VTAmbientLight */ \"./src/VoxelTracer/VTAmbientLight.js\");\n/* harmony import */ var _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RenderProc/VTRenderProc */ \"./src/VoxelTracer/RenderProc/VTRenderProc.js\");\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass VTScene {\r\n  constructor(voxelModel) {\r\n    this.voxelModel = voxelModel;\r\n\r\n    this.childProcesses = [];\r\n\r\n    // TODO: Octree: Split up among the child processes, who then perform the collision detection to determine what they should draw.\r\n\r\n    this.renderables = [];\r\n    this.shadowCasters = [];\r\n    this.lights = [];\r\n\r\n    this.ambientLight = null;\r\n    this.nextId = 0;\r\n\r\n    this._dirtyRemovedObjIds = [];\r\n\r\n    this._renderCount = 0;\r\n    this._forkChildProcesses();\r\n  }\r\n\r\n  get gridSize() { return this.voxelModel.gridSize; }\r\n  getVoxelGridBoundingBox() { return this.voxelModel.getBoundingBox(); }\r\n\r\n  dispose() {\r\n    this.renderables.forEach(renderable => {\r\n      renderable.dispose();\r\n    });\r\n    this.clear();\r\n  }\r\n\r\n  clear() {\r\n    this.renderables = [];\r\n    this.lights = [];\r\n    this.shadowCasters = [];\r\n    this.ambientLight = null;\r\n    this.nextId = 0;\r\n\r\n    this._updateChildRenderProcsFromScene(true);\r\n    this._dirtyRemovedObjIds = [];\r\n  }\r\n\r\n  addLight(l) {\r\n    l.makeDirty();\r\n    if (l instanceof _VTAmbientLight__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) {\r\n      this.ambientLight = l;\r\n    }\r\n    else {\r\n      this.renderables.push(l);\r\n      this.lights.push(l);\r\n    }\r\n    l.id = this.nextId++;\r\n  }\r\n  addObject(o) {\r\n    o.makeDirty();\r\n    this.renderables.push(o);\r\n    if (o.isShadowCaster()) {\r\n      this.shadowCasters.push(o);\r\n    }\r\n    o.id = this.nextId++;\r\n  }\r\n  addFog(f) {\r\n    this.addObject(f);\r\n  }\r\n\r\n  removeObject(o) {\r\n    let index = this.renderables.indexOf(o);\r\n    if (index > -1) {\r\n      this.renderables.splice(index, 1);\r\n      this._dirtyRemovedObjIds.push(o.id);\r\n    }\r\n    index = this.shadowCasters.indexOf(o);\r\n    if (index > -1) {\r\n      this.shadowCasters.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  async render() {\r\n    this._renderCount = 0;\r\n    this._updateChildRenderProcsFromScene();\r\n    for (let i = 0; i < this.childProcesses.length; i++) {\r\n      this.childProcesses[i].send({type: _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].TO_PROC_RENDER});\r\n    }\r\n\r\n    const self = this;\r\n    const waitForRenderToFinish = () => {\r\n      const poll = resolve => {\r\n        if (self._renderCount === self.childProcesses.length) {\r\n          resolve();\r\n        }\r\n        else {\r\n          setTimeout(() => poll(resolve), 1);\r\n          //setImmediate(() => poll(resolve));\r\n        }\r\n      }\r\n      return new Promise(poll);\r\n    };\r\n\r\n    await waitForRenderToFinish();\r\n  }\r\n\r\n  _renderFromChildProcData(renderedVoxels) {\r\n    if (renderedVoxels && renderedVoxels.length > 0) { \r\n      const voxelPt = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n      const voxelColour = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]();\r\n      for (let i = 0; i < renderedVoxels.length; i++) {\r\n        const {pt, colour} = renderedVoxels[i];\r\n\r\n        voxelPt.set(pt.x, pt.y, pt.z);\r\n        voxelColour.setHex(colour);\r\n\r\n        this.voxelModel.addToVoxel(voxelPt, voxelColour);\r\n      }\r\n    }\r\n    this._renderCount++;\r\n  }\r\n\r\n  _getChildProcUpdateAndDirty(reinit=false) {\r\n    let dirty = [];\r\n    let updatedRenderables = [];\r\n    let updatedLights = [];\r\n    let updatedAmbientLight = null;\r\n\r\n    if (reinit) {\r\n      updatedRenderables = [...this.renderables];\r\n      updatedLights = [...this.lights];\r\n      if (this.ambientLight) {\r\n        updatedAmbientLight = this.ambientLight;\r\n        dirty.push(this.ambientLight);\r\n      }\r\n      dirty = [...this.renderables];\r\n    }\r\n    else {\r\n      // N.B., All lights are renderables as well (so we don't need to loop through and add those)\r\n      for (let i = 0; i < this.renderables.length; i++) {\r\n        const renderable = this.renderables[i];\r\n        if (renderable.isDirty()) {\r\n          updatedRenderables.push(renderable);\r\n          dirty.push(renderable);\r\n        }\r\n      }\r\n      for (let i = 0; i < this.lights.length; i++) {\r\n        const light = this.lights[i];\r\n        if (light.isDirty()) {\r\n          updatedLights.push(light);\r\n          // N.B., Lights are already renderables so we don't need to add them to the dirty array\r\n        }\r\n      }\r\n      if (this.ambientLight && this.ambientLight.isDirty()) {\r\n        updatedAmbientLight = this.ambientLight;\r\n        dirty.push(this.ambientLight);\r\n      }\r\n    }\r\n\r\n    // NOTE: We don't include shadowcasters here because it is memoize-able data and can be derived by the child processes\r\n    const childProcUpdate = {\r\n      reinit: reinit,\r\n      renderables: updatedRenderables,\r\n      lights: updatedLights,\r\n      ambientLight: updatedAmbientLight,\r\n    };\r\n\r\n    return {childProcUpdate: childProcUpdate, dirty: dirty};\r\n  }\r\n\r\n  _updateChildRenderProcsFromScene(reinitAll=false) {\r\n    // Make sure the child processes know about any removed objects\r\n    if (this._dirtyRemovedObjIds.length > 0) {\r\n      const updateData = {removedIds: this._dirtyRemovedObjIds};\r\n      for (let i = 0; i < this.childProcesses.length; i++) {\r\n        this.childProcesses[i].send({type: _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].TO_PROC_UPDATE_SCENE, data: updateData});\r\n      }\r\n      this._dirtyRemovedObjIds = [];\r\n    }\r\n\r\n    const {childProcUpdate, dirty} = this._getChildProcUpdateAndDirty(reinitAll);\r\n\r\n    // Update all the dirty items so they have the most up-to-date data in them and\r\n    // are ready to be sent to the child render processes\r\n    for (let i = 0; i < dirty.length; i++) {\r\n      const dirtyObj = dirty[i];\r\n      dirtyObj.unDirty(this);\r\n    }\r\n    \r\n    const boundingBox = this.getVoxelGridBoundingBox();\r\n    const updatedRenderableVoxels = VTScene.getRenderableVoxels(childProcUpdate.renderables, boundingBox);\r\n    const chunkedChildProcData = this._chunkRenderableVoxels(updatedRenderableVoxels);\r\n\r\n    for (let i = 0; i < this.childProcesses.length; i++) {\r\n      const currChildProc = this.childProcesses[i];\r\n\r\n      const updateVoxelInfoObj = {reinit: reinitAll, mapping: chunkedChildProcData[i]};\r\n      if (!reinitAll) { updateVoxelInfoObj['updatedRenderableVoxels'] = updatedRenderableVoxels; }\r\n\r\n      currChildProc.send({type: _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].TO_PROC_UPDATE_VOXEL_INFO, data: updateVoxelInfoObj});\r\n      currChildProc.send({type: _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].TO_PROC_UPDATE_SCENE, data: childProcUpdate});\r\n    }\r\n  }\r\n\r\n  static debugInspectIsOn() {\r\n    return process.execArgv.filter(arg => arg.indexOf('--inspect') !== -1).length > 0;\r\n  }\r\n\r\n  static calcNumChildProcesses() {\r\n    //return (VTSceneTest.debugInspectIsOn()) ? 1 : os.cpus().length;\r\n    return 1;//os.cpus().length;\r\n  }\r\n\r\n  _killChildProcesses() {\r\n    for (let i = 0; i < this.childProcesses.length; i++) {\r\n      if (!this.childProcesses[i].kill()) {\r\n        console.error(\"Failed to properly kill child process.\");\r\n      }\r\n    }\r\n    this.childProcesses = this.childProcesses.filter(c => !c.killed || c.connected);\r\n  }\r\n\r\n  _forkChildProcesses() {\r\n    const self = this;\r\n\r\n    const program = path__WEBPACK_IMPORTED_MODULE_2___default.a.resolve('dist/vtrenderproc.js');\r\n    const programArgs = [];\r\n    const allChildsOptions = {\r\n      stdio: [0, 1, 2, 'ipc'],\r\n      execArgv: [],\r\n    };\r\n    \r\n    const CHILD_PROC_NAME = \"VTRenderProc\";\r\n    let childInspectPort = 31310;\r\n    const debugInspectIsOn = VTScene.debugInspectIsOn();\r\n    const numForks = VTScene.calcNumChildProcesses();\r\n    for (let i = 0; i < numForks; i++) {\r\n      // When debugging node applications we need to make sure each child process has its own inspect port assigned\r\n      // or the program will crash and burn\r\n      let childOptions = allChildsOptions;\r\n      if (debugInspectIsOn) {\r\n        childOptions = {...allChildsOptions,\r\n          execArgv: [...allChildsOptions.execArgv,\r\n            `--inspect=${childInspectPort++}`\r\n          ]\r\n        };\r\n      }\r\n      \r\n      // This will fork off a new child render process\r\n      const childProc = Object(child_process__WEBPACK_IMPORTED_MODULE_3__[\"fork\"])(program, programArgs, childOptions);\r\n      this.childProcesses.push(childProc);\r\n      \r\n      // Setup the child process for various messages between it and this parent process\r\n      childProc.on('message', message => {\r\n        switch (message.type) {\r\n          case _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].FROM_PROC_RENDERED:\r\n            self._renderFromChildProcData(message.data);\r\n            break;\r\n\r\n          default:\r\n            console.log(`Invalid message type recieved from ${CHILD_PROC_NAME}.`);\r\n            break;\r\n        }\r\n      });\r\n\r\n      childProc.on('error', err => console.log(`${CHILD_PROC_NAME} error: ${err}`));\r\n      childProc.on('close', code => console.log(`${CHILD_PROC_NAME} has closed all stdio with code ${code}.`));\r\n\r\n      childProc.on('exit', code => {\r\n        console.log(`${CHILD_PROC_NAME} has exited with code ${code}.`);\r\n        // Remove the child process from the renderer\r\n        this.childProcesses = this.childProcesses.filter(c => c !== childProc);\r\n      });\r\n    }\r\n\r\n    this._initChildProcesses();\r\n  }\r\n\r\n  static getRenderableVoxels(visibleRenderables, boundingBox) {\r\n\r\n    let renderableVoxels = [];\r\n    for (let i = 0; i < visibleRenderables.length; i++) {\r\n      // Get all of the voxels that collide with the renderable object\r\n      const renderable = visibleRenderables[i];\r\n      const voxelPts = renderable.getCollidingVoxels(boundingBox);\r\n      if (voxelPts.length > 0) {\r\n        renderableVoxels.push.apply(renderableVoxels, voxelPts.map(vPt => ({voxelPt: vPt, renderableId: renderable.id})));\r\n      }\r\n    }\r\n\r\n    return renderableVoxels;\r\n  }\r\n\r\n  _chunkRenderableVoxels(renderableVoxels) {\r\n    const numChildProcs = VTScene.calcNumChildProcesses();\r\n    if (renderableVoxels.length === 0) {\r\n      return new Array(numChildProcs).fill().map(() => ({}));\r\n    }\r\n\r\n    // Ordering is important here - the children are only given the voxels in their respective intervals. These intervals are designated as\r\n    // the total number of voxels divided by the total number of children (if it's an uneven division then the last child gets the lesser quantity).\r\n    const numVoxels = this.voxelModel.numVoxels();\r\n    const numVoxelsPerProc = Math.ceil(numVoxels / numChildProcs);\r\n\r\n    const chunkedRenderData = new Array(numChildProcs).fill().map(() => ({}));\r\n    for (let i = 0; i < renderableVoxels.length; i++) {\r\n      const renderableVoxel = renderableVoxels[i];\r\n      const voxelIdx = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_6__[\"default\"].voxelFlatIdx(renderableVoxel.voxelPt, this.voxelModel.gridSize);\r\n      if (voxelIdx >= 0 && voxelIdx < numVoxels) { \r\n        const childProcIdx = Math.floor(voxelIdx / numVoxelsPerProc);\r\n        const childProcChunk = chunkedRenderData[childProcIdx];\r\n\r\n        if (!(renderableVoxel.renderableId in childProcChunk)) {\r\n          childProcChunk[renderableVoxel.renderableId] = [];\r\n        }\r\n        childProcChunk[renderableVoxel.renderableId].push(renderableVoxel.voxelPt);\r\n      }\r\n    }\r\n\r\n    return chunkedRenderData;\r\n  }\r\n\r\n  _initChildProcesses() {\r\n    const numVoxels = this.voxelModel.numVoxels();\r\n    const numVoxelsPerProc = Math.ceil(numVoxels / this.childProcesses.length);\r\n\r\n    // Tell each of the child processes which voxel indices they're responsible for\r\n    for (let i = 0; i < this.childProcesses.length; i++) {\r\n      const currChildProc = this.childProcesses[i];\r\n      currChildProc.send({type: _RenderProc_VTRenderProc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].TO_PROC_INIT, data: {voxelIndexRange: [i*numVoxelsPerProc, i*numVoxelsPerProc + numVoxelsPerProc - 1], gridSize: this.voxelModel.gridSize}});\r\n    }\r\n\r\n    this._updateChildRenderProcsFromScene(true);\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTScene);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTScene.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTTexture.js":
/*!**************************************!*\
  !*** ./src/VoxelTracer/VTTexture.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var get_pixels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-pixels */ \"get-pixels\");\n/* harmony import */ var get_pixels__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(get_pixels__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ndarray */ \"ndarray\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\n\r\nclass VTTexture {\r\n  constructor(imgUrl=null) {\r\n    this.imgData = null;\r\n\r\n    if (imgUrl) {\r\n      let self = this;\r\n      get_pixels__WEBPACK_IMPORTED_MODULE_1___default()(imgUrl, (err, pixels) => {\r\n        if (err) {\r\n          console.log(\"Failed to load image: \" + imgUrl);\r\n          console.log(err);\r\n          return;\r\n        }\r\n\r\n        if (pixels.shape.length === 4) {\r\n          console.log(\"Invalid texture dimension, scaling down...\");\r\n          pixels = pixels.pick(0);\r\n        }\r\n        \r\n        /*\r\n        console.log(\"Size: \" + pixels.size);\r\n        console.log(\"Shape: \" + pixels.shape);\r\n        console.log(\"Stride: \" + pixels.stride);\r\n        console.log(\"Offset: \" + pixels.offset);\r\n        */\r\n\r\n        // Normalize the image data into floating point [0,1] colour data\r\n        const fpData = ndarray__WEBPACK_IMPORTED_MODULE_2___default()(new Float32Array(pixels.size), pixels.shape, pixels.stride, pixels.offset);\r\n        \r\n        for (let i = 0; i < pixels.shape[0]; i++) {\r\n          for (let j = 0; j < pixels.shape[1]; j++) {\r\n            for (let k = 0; k < pixels.shape[2]; k++) {\r\n              fpData.set(i,j,k, pixels.get(i,j,k)/255.0);\r\n              //console.log(fpData.get(i,j,k));\r\n            }\r\n          }\r\n        }\r\n        self.imgData = fpData;\r\n        /*\r\n        for (let i = 0; i < pixels.shape[0]; i++) {\r\n          for (let j = 0; j < pixels.shape[1]; j++) {\r\n            console.log(\"r: \" + self.imgData.get(i,j,0) + \", g: \" + self.imgData.get(i,j,1) + \", b: \" + self.imgData.get(i,j,2));\r\n          }\r\n        }\r\n        */\r\n      });\r\n    }\r\n  }\r\n\r\n  static build(jsonData) {\r\n    if (!jsonData) { return null; }\r\n    const {imgData} = jsonData;\r\n    const result = new VTTexture(null);\r\n    result.imgData = imgData;\r\n    return result;\r\n  }\r\n\r\n  toJSON() {\r\n    const {imgData} = this;\r\n    return {imgData};\r\n  }\r\n\r\n  isLoaded() {\r\n    return this.imgData !== null;\r\n  }\r\n\r\n  /**\r\n   * Get a sample (i.e., an array of the channels) at the given u,v coordinates in this texture.\r\n   */\r\n  sample(uv) {\r\n    if (!this.isLoaded()) {\r\n      return null;\r\n    }\r\n    // NOTE: Assumption that uv coordinates are in [0,1]\r\n    const uIdx = Math.floor(uv.x * (this.imgData.shape[0]-1));\r\n    const vIdx = Math.floor(uv.y * (this.imgData.shape[1]-1));\r\n    //console.log(\"r: \" + this.imgData.get(uIdx,vIdx,0) + \", g: \" + this.imgData.get(uIdx,vIdx,1) + \", b: \" + this.imgData.get(uIdx,vIdx,2));\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](\r\n      this.imgData.get(uIdx,vIdx,0),\r\n      this.imgData.get(uIdx,vIdx,1),\r\n      this.imgData.get(uIdx,vIdx,2)\r\n    );\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTTexture);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTTexture.js?");

/***/ }),

/***/ "./src/VoxelTracer/VTVoxel.js":
/*!************************************!*\
  !*** ./src/VoxelTracer/VTVoxel.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Server/VoxelModel */ \"./src/Server/VoxelModel.js\");\n/* harmony import */ var _VTRenderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTRenderable */ \"./src/VoxelTracer/VTRenderable.js\");\n/* harmony import */ var _VTMaterialFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VTMaterialFactory */ \"./src/VoxelTracer/VTMaterialFactory.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass VTVoxel extends _VTRenderable__WEBPACK_IMPORTED_MODULE_2__[\"default\"]  {\r\n\r\n  constructor(voxelIdxPt, material, options={}) {\r\n    super(_VTRenderable__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VOXEL_TYPE);\r\n\r\n    this._voxelIdxPt = voxelIdxPt;\r\n    this._material = material;\r\n    this._matrixWorld = (options.matrixWorld !== undefined) ? options.matrixWorld : new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\r\n    this._receivesShadow = (options.receivesShadow !== undefined) ? options.receivesShadow : true;\r\n\r\n    // Temp variable for calculations\r\n    this._tempVec3 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n    this.computeBoundingBox();\r\n\r\n    this.makeDirty();\r\n  }\r\n\r\n  static build(jsonData) {\r\n    const {id, _voxelIdxPt, _material, matrixArray, _receivesShadow} = jsonData;\r\n    const result = new VTVoxel(\r\n      new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](_voxelIdxPt.x, _voxelIdxPt.y, _voxelIdxPt.z), \r\n      _VTMaterialFactory__WEBPACK_IMPORTED_MODULE_3__[\"default\"].build(_material), \r\n      {receivesShadow: _receivesShadow, matrixWorld: (new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]()).fromArray(matrixArray)}\r\n    );\r\n    result.id = id;\r\n    return result;\r\n  }\r\n\r\n  get material() { return this._material; }\r\n  setMaterial(m) { this._material = m; this.makeDirty(); }\r\n  setMatrixWorld(m) { this._matrixWorld = m; this.computeBoundingBox(); this.makeDirty(); }\r\n  setReceivesShadow(r) { this._receivesShadow = r; this.makeDirty(); }\r\n\r\n  dispose() {\r\n    this._material.dispose();\r\n  }\r\n\r\n  isDirty() { return this._isDirty; }\r\n  \r\n  makeDirty() { this._isDirty = true; }\r\n\r\n  unDirty(scene=null) {\r\n    if (this._isDirty) {\r\n      this._isDirty = false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  isShadowCaster() { return true; }\r\n\r\n  toJSON() {\r\n    const {id, type, _voxelIdxPt, _material, _matrixWorld, _receivesShadow} = this;\r\n    const matrixArray = _matrixWorld.toArray();\r\n    return {id, type, _voxelIdxPt, _material, matrixArray, _receivesShadow};\r\n  }\r\n\r\n  _getWorldSpacePosition(target) {\r\n    target.copy(this._voxelIdxPt);\r\n    target.applyMatrix4(this._matrixWorld);\r\n    return target;\r\n  }\r\n\r\n  computeBoundingBox() {\r\n    this._getWorldSpacePosition(this._tempVec3);\r\n    this._boundingBox = _Server_VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].calcVoxelBoundingBox(_Server_VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].closestVoxelIdxPt(this._tempVec3));\r\n  }\r\n\r\n  calculateShadow(raycaster) {\r\n    return {\r\n      inShadow: this.intersectsRay(raycaster),\r\n      lightReduction: 1.0, // [0,1]: 1 => Completely black out the light if a voxel is in shadow from this object\r\n    };\r\n  }\r\n\r\n  calculateVoxelColour(voxelIdxPt=null, scene) {\r\n    // Fast-out if we can't even see this voxel\r\n    if (!this._material.isVisible()) {\r\n      return new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0,0,0);\r\n    }\r\n\r\n    this._getWorldSpacePosition(this._tempVec3);\r\n    return scene.calculateVoxelLighting(this._tempVec3, this._material, this._receivesShadow);\r\n  }\r\n\r\n  intersectsBox(box) {\r\n    return this._boundingBox.intersectsBox(box);\r\n  }\r\n\r\n  intersectsRay(raycaster) {\r\n    return raycaster.ray.intersectsBox(this._boundingBox, this._tempVec3) !== null;\r\n  }\r\n\r\n  getCollidingVoxels(voxelBoundingBox=null) {\r\n    return [_Server_VoxelModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"].closestVoxelIdxPt(this._voxelIdxPt)];\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VTVoxel);\n\n//# sourceURL=webpack:///./src/VoxelTracer/VTVoxel.js?");

/***/ }),

/***/ "./src/WebClientViewer/SoundController.js":
/*!************************************************!*\
  !*** ./src/WebClientViewer/SoundController.js ***!
  \************************************************/
/*! exports provided: DEFAULT_NUM_FFT_SAMPLES, DEFAULT_FFT_BUFFER_SIZE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_NUM_FFT_SAMPLES\", function() { return DEFAULT_NUM_FFT_SAMPLES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_FFT_BUFFER_SIZE\", function() { return DEFAULT_FFT_BUFFER_SIZE; });\n/* harmony import */ var meyda__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! meyda */ \"meyda\");\n/* harmony import */ var meyda__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(meyda__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nconst DEFAULT_NUM_FFT_SAMPLES = 1;\r\nconst DEFAULT_FFT_BUFFER_SIZE = 2048;\r\n\r\nclass SoundController {\r\n  constructor() {\r\n\r\n    if (window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext')) {\r\n      window.AudioContext = webkitAudioContext;\r\n    }\r\n\r\n    if (navigator.hasOwnProperty('webkitGetUserMedia') && !navigator.hasOwnProperty('getUserMedia')) {\r\n      navigator.getUserMedia = webkitGetUserMedia;\r\n      if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor')) {\r\n        AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;\r\n      }\r\n    }\r\n\r\n    this.enabled = false;\r\n    this.numFFTSamples = DEFAULT_NUM_FFT_SAMPLES;\r\n    this.fftBufferSize = DEFAULT_FFT_BUFFER_SIZE;\r\n\r\n    // Debug renderer variables\r\n    this.showDebug = false;\r\n\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    this._soundDebugScene  = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\r\n    this._soundDebugCamera = new three__WEBPACK_IMPORTED_MODULE_1__[\"PerspectiveCamera\"](75, width/height, 0.1, 1000);\r\n    this._soundDebugSceneOrtho  = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\r\n    this._soundDebugCameraOrtho = new three__WEBPACK_IMPORTED_MODULE_1__[\"OrthographicCamera\"](-width/2, width/2, height/2, -height/2, 1, 10);\r\n    this._soundDebugScene.position.set(0,0,0);\r\n    this._soundDebugCamera.position.set(0,0,10);\r\n\r\n    this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_1__[\"WebGLRenderTarget\"](width, height, {minFilter: three__WEBPACK_IMPORTED_MODULE_1__[\"LinearMipMapLinearFilter\"], magFilter: three__WEBPACK_IMPORTED_MODULE_1__[\"LinearFilter\"], format: three__WEBPACK_IMPORTED_MODULE_1__[\"RGBAFormat\"]});\r\n    let spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"SpriteMaterial\"]({map:this._renderTarget.texture, blending:three__WEBPACK_IMPORTED_MODULE_1__[\"AdditiveBlending\"]});\r\n    this._renderTargetSprite = new three__WEBPACK_IMPORTED_MODULE_1__[\"Sprite\"](spriteMaterial)\r\n    this._soundDebugSceneOrtho.add(this._renderTargetSprite);\r\n    this._updateSprite();\r\n\r\n    this.context = new AudioContext();\r\n    this._initializeMicrophoneSampling();\r\n    this._initializeFFTs(); // NOTE: The number of FFTs must be a multiple of 8 for the visualizer to work properly!!!\r\n    \r\n  }\r\n\r\n  _initializeFFTs() {\r\n    this.ffts = [];\r\n    for (let i = 0; i < this.numFFTSamples; i++) {\r\n      this.ffts.push(new Array(this.fftBufferSize));\r\n    }\r\n    this._initRenderFFTs();\r\n  }\r\n  _initRenderFFTs() {\r\n    if (this._lines) {\r\n      this._soundDebugScene.remove(this._lines);\r\n    }\r\n\r\n    this._lines = new three__WEBPACK_IMPORTED_MODULE_1__[\"Group\"]();\r\n    let material = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineBasicMaterial\"]({color:0x00ff00});\r\n    for (let i = 0; i < this.ffts.length; i++) {\r\n      let geometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"BufferGeometry\"]();\r\n      let positions = new Float32Array(this.ffts[i].length * 3);\r\n\r\n      geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_1__[\"BufferAttribute\"](positions, 3));\r\n      geometry.setDrawRange(0, this.ffts[i].length);\r\n\r\n      let line = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](geometry, material);\r\n      this._lines.add(line);\r\n\r\n      positions = line.geometry.attributes.position.array;\r\n    }\r\n\r\n    this._soundDebugScene.add(this._lines);\r\n\r\n    /*\r\n    let bufferLineGeometry = new THREE.BufferGeometry();\r\n    this._bufferLine = new THREE.Line(bufferLineGeometry, material);\r\n    {\r\n      let positions = new Float32Array(this.fftBufferSize * 3);\r\n      bufferLineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n      bufferLineGeometry.setDrawRange(0, this.fftBufferSize);\r\n      positions = this._bufferLine.geometry.attributes.position.array;\r\n    }\r\n    */\r\n  }\r\n\r\n\r\n  _initializeMicrophoneSampling() {\r\n    const errorCallback = function (err) {\r\n      console.error(\"Failed to initialize microphone: \" + err);\r\n    };\r\n\r\n    const self = this;\r\n\r\n    try {\r\n      navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.getUserMedia || navigator.mediaDevices.getUserMedia;\r\n      const constraints = { video: false, audio: true };\r\n\r\n      const successCallback = function (mediaStream) {\r\n        console.log('User allowed microphone access.');\r\n        console.log('Initializing AudioNode from MediaStream');\r\n\r\n        const source = self.context.createMediaStreamSource(mediaStream);\r\n\r\n        console.log('Setting Meyda Source to Microphone');\r\n        self.meyda = meyda__WEBPACK_IMPORTED_MODULE_0___default.a.createMeydaAnalyzer({\r\n          audioContext: self.context,\r\n          source: source,\r\n          bufferSize: self.fftBufferSize,\r\n          windowingFunction: 'hanning',\r\n        });\r\n        console.groupEnd();\r\n      };\r\n\r\n      console.log('Asking for permission...');\r\n      const getUserMediaPromise = navigator.getUserMedia(\r\n        constraints,\r\n        successCallback,\r\n        errorCallback\r\n      );\r\n      if (getUserMediaPromise) {\r\n        p.then(successCallback);\r\n        p.catch(errorCallback);\r\n      }\r\n    }\r\n    catch (e) {\r\n      errorCallback();\r\n    }\r\n  }\r\n\r\n  _getAudioFeatures(features) {\r\n    this.context.resume();\r\n    return this.meyda ? this.meyda.get(features) : null;\r\n  }\r\n\r\n  setFFTNumSamples(num) {\r\n    this.numFFTSamples = num;\r\n    this._initializeFFTs();\r\n  }\r\n\r\n  sample(voxelClient) {\r\n    if (!this.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.features = this._getAudioFeatures([\r\n      'amplitudeSpectrum',\r\n      'spectralCentroid',\r\n      'spectralRolloff',\r\n      //'loudness',\r\n      'rms',\r\n      //'mfcc'\r\n    ]);\r\n\r\n    if (!this.features) {\r\n      return;\r\n    }\r\n\r\n    this.ffts.pop();\r\n    this.ffts.unshift(this.features.amplitudeSpectrum);\r\n\r\n    // Send the most recent FFT and feature info to the server\r\n    voxelClient.sendAudioInfo({\r\n      fft: this.ffts[0],\r\n      rms: this.features.rms,\r\n      spectralRolloff: this.features.spectralRolloff,\r\n      spectralCentroid: this.features.spectralCentroid,\r\n    });\r\n  }\r\n\r\n  _updateFFTDebugGeometry() {\r\n    for (let i = 0; i < this.ffts.length; i++) {\r\n      const positions = this._lines.children[i].geometry.attributes.position.array;\r\n      let index = 0;\r\n\r\n      for (var j = 0; j < this.ffts[i].length+1; j++) {\r\n        positions[index++] = 11.7 + (8 * Math.log10(j/this.ffts[i].length));\r\n        positions[index++] = -6.5 + 0.1 * this.ffts[i][j];\r\n        positions[index++] = -1 - i;\r\n      }\r\n\r\n      this._lines.children[i].geometry.attributes.position.needsUpdate = true;\r\n    }\r\n  }\r\n\r\n  _updateSprite() {\r\n    const width  = window.innerWidth;\r\n    const height = window.innerHeight;\r\n    const halfWidth = width/2;\r\n    const halfHeight = height/2;\r\n    const spriteWidth  = width/2;\r\n    const spriteHeight = height/2;\r\n\r\n    this._renderTargetSprite.scale.set(spriteWidth, spriteHeight, 1);\r\n    this._renderTargetSprite.position.set(-halfWidth+spriteWidth/2, -halfHeight+spriteHeight/2, -1);\r\n  }\r\n  \r\n  render(renderer) {\r\n    if (!this.showDebug || !this.enabled) {\r\n      return;\r\n    }\r\n    this._updateFFTDebugGeometry();\r\n\r\n    // Render the Sound data to a render target (texture)\r\n    renderer.setRenderTarget(this._renderTarget);\r\n    renderer.clear();\r\n    renderer.render(this._soundDebugScene, this._soundDebugCamera);\r\n    renderer.setRenderTarget(null);\r\n\r\n    // Render the texture onto the screen\r\n    renderer.render(this._soundDebugSceneOrtho, this._soundDebugCameraOrtho);\r\n  }\r\n\r\n  windowResize(originalTanFOV, originalWindowHeight) {\r\n    const width  = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    this._soundDebugCamera.aspect = width / height;\r\n    this._soundDebugCamera.fov = (360 / Math.PI) * Math.atan(originalTanFOV * (height / originalWindowHeight));\r\n    this._soundDebugCamera.updateProjectionMatrix();\r\n    this._soundDebugCamera.lookAt(this._soundDebugScene.position);\r\n\r\n    this._soundDebugCameraOrtho.left = -width/2;\r\n    this._soundDebugCameraOrtho.right = width/2;\r\n    this._soundDebugCameraOrtho.top = height/2;\r\n    this._soundDebugCameraOrtho.bottom = -height/2;\r\n    this._soundDebugCameraOrtho.updateProjectionMatrix();\r\n\r\n    this._updateSprite();\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SoundController);\n\n//# sourceURL=webpack:///./src/WebClientViewer/SoundController.js?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack:///external_%22child_process%22?");

/***/ }),

/***/ "chroma-js":
/*!****************************!*\
  !*** external "chroma-js" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"chroma-js\");\n\n//# sourceURL=webpack:///external_%22chroma-js%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "get-pixels":
/*!*****************************!*\
  !*** external "get-pixels" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"get-pixels\");\n\n//# sourceURL=webpack:///external_%22get-pixels%22?");

/***/ }),

/***/ "gpu.js":
/*!*************************!*\
  !*** external "gpu.js" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"gpu.js\");\n\n//# sourceURL=webpack:///external_%22gpu.js%22?");

/***/ }),

/***/ "meyda":
/*!************************!*\
  !*** external "meyda" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"meyda\");\n\n//# sourceURL=webpack:///external_%22meyda%22?");

/***/ }),

/***/ "ndarray":
/*!**************************!*\
  !*** external "ndarray" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"ndarray\");\n\n//# sourceURL=webpack:///external_%22ndarray%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "three" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"three\");\n\n//# sourceURL=webpack:///external_%22three%22?");

/***/ }),

/***/ "three-mesh-bvh":
/*!*********************************!*\
  !*** external "three-mesh-bvh" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"three-mesh-bvh\");\n\n//# sourceURL=webpack:///external_%22three-mesh-bvh%22?");

/***/ })

/******/ });